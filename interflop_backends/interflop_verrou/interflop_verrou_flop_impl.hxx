// generated by : ['./gen_interflop_verrou_flop_impl.py']
#define IFV_INLINE

IFV_INLINE void IFV_FCTNAME(sqrt_double) (double a, double* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<SqrtOp <double> > Op;
  Op::apply(Op::PackArgs(a),res,context);
}


IFV_INLINE void IFV_FCTNAME(sqrt_float) (float a, float* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<SqrtOp <float> > Op;
  Op::apply(Op::PackArgs(a),res,context);
}


IFV_INLINE void IFV_FCTNAME(add_double) (double a, double b, double* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<AddOp <double> > Op;
  Op::apply(Op::PackArgs(a,b),res,context);
}


IFV_INLINE void IFV_FCTNAME(add_float) (float a, float b, float* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<AddOp <float> > Op;
  Op::apply(Op::PackArgs(a,b),res,context);
}


IFV_INLINE void IFV_FCTNAME(sub_double) (double a, double b, double* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<SubOp <double> > Op;
  Op::apply(Op::PackArgs(a,b),res,context);
}


IFV_INLINE void IFV_FCTNAME(sub_float) (float a, float b, float* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<SubOp <float> > Op;
  Op::apply(Op::PackArgs(a,b),res,context);
}


IFV_INLINE void IFV_FCTNAME(mul_double) (double a, double b, double* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<MulOp <double> > Op;
  Op::apply(Op::PackArgs(a,b),res,context);
}


IFV_INLINE void IFV_FCTNAME(mul_float) (float a, float b, float* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<MulOp <float> > Op;
  Op::apply(Op::PackArgs(a,b),res,context);
}


IFV_INLINE void IFV_FCTNAME(div_double) (double a, double b, double* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<DivOp <double> > Op;
  Op::apply(Op::PackArgs(a,b),res,context);
}


IFV_INLINE void IFV_FCTNAME(div_float) (float a, float b, float* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<DivOp <float> > Op;
  Op::apply(Op::PackArgs(a,b),res,context);
}


IFV_INLINE void IFV_FCTNAME(madd_double) (double a, double b, double c, double* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<MAddOp <double> > Op;
  Op::apply(Op::PackArgs(a,b,c),res,context);
}


IFV_INLINE void IFV_FCTNAME(madd_float) (float a, float b, float c, float* res,void* context) {
  typedef OpWithDynSelectedRoundingMode<MAddOp <float> > Op;
  Op::apply(Op::PackArgs(a,b,c),res,context);
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float) (double a, float* res, void* context){
  typedef OpWithDynSelectedRoundingMode<CastOp<double,float> > Op;
  Op::apply(Op::PackArgs(a),res,context);
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_NEAREST) (double a, double* res,void* context) {
  typedef RoundingNearest<SqrtOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_NEAREST) (float a, float* res,void* context) {
  typedef RoundingNearest<SqrtOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_NEAREST) (double a, double b, double* res,void* context) {
  typedef RoundingNearest<AddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_NEAREST) (float a, float b, float* res,void* context) {
  typedef RoundingNearest<AddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_NEAREST) (double a, double b, double* res,void* context) {
  typedef RoundingNearest<SubOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_NEAREST) (float a, float b, float* res,void* context) {
  typedef RoundingNearest<SubOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_NEAREST) (double a, double b, double* res,void* context) {
  typedef RoundingNearest<MulOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_NEAREST) (float a, float b, float* res,void* context) {
  typedef RoundingNearest<MulOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_NEAREST) (double a, double b, double* res,void* context) {
  typedef RoundingNearest<DivOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_NEAREST) (float a, float b, float* res,void* context) {
  typedef RoundingNearest<DivOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_NEAREST) (double a, double b, double c, double* res,void* context) {
  typedef RoundingNearest<MAddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_NEAREST) (float a, float b, float c, float* res,void* context) {
  typedef RoundingNearest<MAddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_NEAREST) (double a, float* res, void* context){
  typedef RoundingNearest<CastOp<double,float> > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_UPWARD) (double a, double* res,void* context) {
  typedef RoundingUpward<SqrtOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_UPWARD) (float a, float* res,void* context) {
  typedef RoundingUpward<SqrtOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_UPWARD) (double a, double b, double* res,void* context) {
  typedef RoundingUpward<AddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_UPWARD) (float a, float b, float* res,void* context) {
  typedef RoundingUpward<AddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_UPWARD) (double a, double b, double* res,void* context) {
  typedef RoundingUpward<SubOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_UPWARD) (float a, float b, float* res,void* context) {
  typedef RoundingUpward<SubOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_UPWARD) (double a, double b, double* res,void* context) {
  typedef RoundingUpward<MulOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_UPWARD) (float a, float b, float* res,void* context) {
  typedef RoundingUpward<MulOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_UPWARD) (double a, double b, double* res,void* context) {
  typedef RoundingUpward<DivOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_UPWARD) (float a, float b, float* res,void* context) {
  typedef RoundingUpward<DivOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_UPWARD) (double a, double b, double c, double* res,void* context) {
  typedef RoundingUpward<MAddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_UPWARD) (float a, float b, float c, float* res,void* context) {
  typedef RoundingUpward<MAddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_UPWARD) (double a, float* res, void* context){
  typedef RoundingUpward<CastOp<double,float> > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_DOWNWARD) (double a, double* res,void* context) {
  typedef RoundingDownward<SqrtOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_DOWNWARD) (float a, float* res,void* context) {
  typedef RoundingDownward<SqrtOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_DOWNWARD) (double a, double b, double* res,void* context) {
  typedef RoundingDownward<AddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_DOWNWARD) (float a, float b, float* res,void* context) {
  typedef RoundingDownward<AddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_DOWNWARD) (double a, double b, double* res,void* context) {
  typedef RoundingDownward<SubOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_DOWNWARD) (float a, float b, float* res,void* context) {
  typedef RoundingDownward<SubOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_DOWNWARD) (double a, double b, double* res,void* context) {
  typedef RoundingDownward<MulOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_DOWNWARD) (float a, float b, float* res,void* context) {
  typedef RoundingDownward<MulOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_DOWNWARD) (double a, double b, double* res,void* context) {
  typedef RoundingDownward<DivOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_DOWNWARD) (float a, float b, float* res,void* context) {
  typedef RoundingDownward<DivOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_DOWNWARD) (double a, double b, double c, double* res,void* context) {
  typedef RoundingDownward<MAddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_DOWNWARD) (float a, float b, float c, float* res,void* context) {
  typedef RoundingDownward<MAddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_DOWNWARD) (double a, float* res, void* context){
  typedef RoundingDownward<CastOp<double,float> > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_FARTHEST) (double a, double* res,void* context) {
  typedef RoundingFarthest<SqrtOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_FARTHEST) (float a, float* res,void* context) {
  typedef RoundingFarthest<SqrtOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_FARTHEST) (double a, double b, double* res,void* context) {
  typedef RoundingFarthest<AddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_FARTHEST) (float a, float b, float* res,void* context) {
  typedef RoundingFarthest<AddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_FARTHEST) (double a, double b, double* res,void* context) {
  typedef RoundingFarthest<SubOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_FARTHEST) (float a, float b, float* res,void* context) {
  typedef RoundingFarthest<SubOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_FARTHEST) (double a, double b, double* res,void* context) {
  typedef RoundingFarthest<MulOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_FARTHEST) (float a, float b, float* res,void* context) {
  typedef RoundingFarthest<MulOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_FARTHEST) (double a, double b, double* res,void* context) {
  typedef RoundingFarthest<DivOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_FARTHEST) (float a, float b, float* res,void* context) {
  typedef RoundingFarthest<DivOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_FARTHEST) (double a, double b, double c, double* res,void* context) {
  typedef RoundingFarthest<MAddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_FARTHEST) (float a, float b, float c, float* res,void* context) {
  typedef RoundingFarthest<MAddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_FARTHEST) (double a, float* res, void* context){
  typedef RoundingFarthest<CastOp<double,float> > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_ZERO) (double a, double* res,void* context) {
  typedef RoundingZero<SqrtOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_ZERO) (float a, float* res,void* context) {
  typedef RoundingZero<SqrtOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_ZERO) (double a, double b, double* res,void* context) {
  typedef RoundingZero<AddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_ZERO) (float a, float b, float* res,void* context) {
  typedef RoundingZero<AddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_ZERO) (double a, double b, double* res,void* context) {
  typedef RoundingZero<SubOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_ZERO) (float a, float b, float* res,void* context) {
  typedef RoundingZero<SubOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_ZERO) (double a, double b, double* res,void* context) {
  typedef RoundingZero<MulOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_ZERO) (float a, float b, float* res,void* context) {
  typedef RoundingZero<MulOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_ZERO) (double a, double b, double* res,void* context) {
  typedef RoundingZero<DivOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_ZERO) (float a, float b, float* res,void* context) {
  typedef RoundingZero<DivOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_ZERO) (double a, double b, double c, double* res,void* context) {
  typedef RoundingZero<MAddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_ZERO) (float a, float b, float c, float* res,void* context) {
  typedef RoundingZero<MAddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_ZERO) (double a, float* res, void* context){
  typedef RoundingZero<CastOp<double,float> > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_AWAY_ZERO) (double a, double* res,void* context) {
  typedef RoundingAwayZero<SqrtOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_AWAY_ZERO) (float a, float* res,void* context) {
  typedef RoundingAwayZero<SqrtOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_AWAY_ZERO) (double a, double b, double* res,void* context) {
  typedef RoundingAwayZero<AddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_AWAY_ZERO) (float a, float b, float* res,void* context) {
  typedef RoundingAwayZero<AddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_AWAY_ZERO) (double a, double b, double* res,void* context) {
  typedef RoundingAwayZero<SubOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_AWAY_ZERO) (float a, float b, float* res,void* context) {
  typedef RoundingAwayZero<SubOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_AWAY_ZERO) (double a, double b, double* res,void* context) {
  typedef RoundingAwayZero<MulOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_AWAY_ZERO) (float a, float b, float* res,void* context) {
  typedef RoundingAwayZero<MulOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_AWAY_ZERO) (double a, double b, double* res,void* context) {
  typedef RoundingAwayZero<DivOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_AWAY_ZERO) (float a, float b, float* res,void* context) {
  typedef RoundingAwayZero<DivOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_AWAY_ZERO) (double a, double b, double c, double* res,void* context) {
  typedef RoundingAwayZero<MAddOp <double> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_AWAY_ZERO) (float a, float b, float c, float* res,void* context) {
  typedef RoundingAwayZero<MAddOp <float> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_AWAY_ZERO) (double a, float* res, void* context){
  typedef RoundingAwayZero<CastOp<double,float> > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_RANDOM) (double a, double* res,void* context) {
  typedef RoundingRandom<SqrtOp <double> ,vr_rand_prng<SqrtOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_RANDOM) (float a, float* res,void* context) {
  typedef RoundingRandom<SqrtOp <float> ,vr_rand_prng<SqrtOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_RANDOM) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<AddOp <double> ,vr_rand_prng<AddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_RANDOM) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<AddOp <float> ,vr_rand_prng<AddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_RANDOM) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<SubOp <double> ,vr_rand_prng<SubOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_RANDOM) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<SubOp <float> ,vr_rand_prng<SubOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_RANDOM) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<MulOp <double> ,vr_rand_prng<MulOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_RANDOM) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<MulOp <float> ,vr_rand_prng<MulOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_RANDOM) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<DivOp <double> ,vr_rand_prng<DivOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_RANDOM) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<DivOp <float> ,vr_rand_prng<DivOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_RANDOM) (double a, double b, double c, double* res,void* context) {
  typedef RoundingRandom<MAddOp <double> ,vr_rand_prng<MAddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_RANDOM) (float a, float b, float c, float* res,void* context) {
  typedef RoundingRandom<MAddOp <float> ,vr_rand_prng<MAddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_RANDOM) (double a, float* res, void* context){
  typedef RoundingRandom<CastOp<double,float> ,vr_rand_prng<CastOp <double,float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_RANDOM_DET) (double a, double* res,void* context) {
  typedef RoundingRandom<SqrtOp <double> ,vr_rand_det<SqrtOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_RANDOM_DET) (float a, float* res,void* context) {
  typedef RoundingRandom<SqrtOp <float> ,vr_rand_det<SqrtOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_RANDOM_DET) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<AddOp <double> ,vr_rand_det<AddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_RANDOM_DET) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<AddOp <float> ,vr_rand_det<AddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_RANDOM_DET) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<SubOp <double> ,vr_rand_det<SubOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_RANDOM_DET) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<SubOp <float> ,vr_rand_det<SubOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_RANDOM_DET) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<MulOp <double> ,vr_rand_det<MulOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_RANDOM_DET) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<MulOp <float> ,vr_rand_det<MulOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_RANDOM_DET) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<DivOp <double> ,vr_rand_det<DivOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_RANDOM_DET) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<DivOp <float> ,vr_rand_det<DivOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_RANDOM_DET) (double a, double b, double c, double* res,void* context) {
  typedef RoundingRandom<MAddOp <double> ,vr_rand_det<MAddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_RANDOM_DET) (float a, float b, float c, float* res,void* context) {
  typedef RoundingRandom<MAddOp <float> ,vr_rand_det<MAddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_RANDOM_DET) (double a, float* res, void* context){
  typedef RoundingRandom<CastOp<double,float> ,vr_rand_det<CastOp <double,float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_RANDOM_COMDET) (double a, double* res,void* context) {
  typedef RoundingRandom<SqrtOp <double> ,vr_rand_comdet<SqrtOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_RANDOM_COMDET) (float a, float* res,void* context) {
  typedef RoundingRandom<SqrtOp <float> ,vr_rand_comdet<SqrtOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_RANDOM_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<AddOp <double> ,vr_rand_comdet<AddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_RANDOM_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<AddOp <float> ,vr_rand_comdet<AddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_RANDOM_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<SubOp <double> ,vr_rand_comdet<SubOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_RANDOM_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<SubOp <float> ,vr_rand_comdet<SubOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_RANDOM_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<MulOp <double> ,vr_rand_comdet<MulOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_RANDOM_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<MulOp <float> ,vr_rand_comdet<MulOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_RANDOM_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingRandom<DivOp <double> ,vr_rand_comdet<DivOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_RANDOM_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingRandom<DivOp <float> ,vr_rand_comdet<DivOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_RANDOM_COMDET) (double a, double b, double c, double* res,void* context) {
  typedef RoundingRandom<MAddOp <double> ,vr_rand_comdet<MAddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_RANDOM_COMDET) (float a, float b, float c, float* res,void* context) {
  typedef RoundingRandom<MAddOp <float> ,vr_rand_comdet<MAddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_RANDOM_COMDET) (double a, float* res, void* context){
  typedef RoundingRandom<CastOp<double,float> ,vr_rand_comdet<CastOp <double,float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_RANDOM_SCOMDET) (double a, double* res,void* context) {
  typedef RoundingPRandom<SqrtOp <double> ,vr_rand_scomdet<SqrtOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_RANDOM_SCOMDET) (float a, float* res,void* context) {
  typedef RoundingPRandom<SqrtOp <float> ,vr_rand_scomdet<SqrtOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_RANDOM_SCOMDET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<AddOp <double> ,vr_rand_scomdet<AddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_RANDOM_SCOMDET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<AddOp <float> ,vr_rand_scomdet<AddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_RANDOM_SCOMDET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<SubOp <double> ,vr_rand_scomdet<SubOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_RANDOM_SCOMDET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<SubOp <float> ,vr_rand_scomdet<SubOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_RANDOM_SCOMDET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<MulOp <double> ,vr_rand_scomdet<MulOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_RANDOM_SCOMDET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<MulOp <float> ,vr_rand_scomdet<MulOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_RANDOM_SCOMDET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<DivOp <double> ,vr_rand_scomdet<DivOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_RANDOM_SCOMDET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<DivOp <float> ,vr_rand_scomdet<DivOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_RANDOM_SCOMDET) (double a, double b, double c, double* res,void* context) {
  typedef RoundingPRandom<MAddOp <double> ,vr_rand_scomdet<MAddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_RANDOM_SCOMDET) (float a, float b, float c, float* res,void* context) {
  typedef RoundingPRandom<MAddOp <float> ,vr_rand_scomdet<MAddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_RANDOM_SCOMDET) (double a, float* res, void* context){
  typedef RoundingPRandom<CastOp<double,float> ,vr_rand_scomdet<CastOp <double,float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_AVERAGE) (double a, double* res,void* context) {
  typedef RoundingAverage<SqrtOp <double> ,vr_rand_prng<SqrtOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_AVERAGE) (float a, float* res,void* context) {
  typedef RoundingAverage<SqrtOp <float> ,vr_rand_prng<SqrtOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_AVERAGE) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<AddOp <double> ,vr_rand_prng<AddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_AVERAGE) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<AddOp <float> ,vr_rand_prng<AddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_AVERAGE) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<SubOp <double> ,vr_rand_prng<SubOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_AVERAGE) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<SubOp <float> ,vr_rand_prng<SubOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_AVERAGE) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<MulOp <double> ,vr_rand_prng<MulOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_AVERAGE) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<MulOp <float> ,vr_rand_prng<MulOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_AVERAGE) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<DivOp <double> ,vr_rand_prng<DivOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_AVERAGE) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<DivOp <float> ,vr_rand_prng<DivOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_AVERAGE) (double a, double b, double c, double* res,void* context) {
  typedef RoundingAverage<MAddOp <double> ,vr_rand_prng<MAddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_AVERAGE) (float a, float b, float c, float* res,void* context) {
  typedef RoundingAverage<MAddOp <float> ,vr_rand_prng<MAddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_AVERAGE) (double a, float* res, void* context){
  typedef RoundingAverage<CastOp<double,float> ,vr_rand_prng<CastOp <double,float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_AVERAGE_DET) (double a, double* res,void* context) {
  typedef RoundingAverage<SqrtOp <double> ,vr_rand_det<SqrtOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_AVERAGE_DET) (float a, float* res,void* context) {
  typedef RoundingAverage<SqrtOp <float> ,vr_rand_det<SqrtOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_AVERAGE_DET) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<AddOp <double> ,vr_rand_det<AddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_AVERAGE_DET) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<AddOp <float> ,vr_rand_det<AddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_AVERAGE_DET) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<SubOp <double> ,vr_rand_det<SubOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_AVERAGE_DET) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<SubOp <float> ,vr_rand_det<SubOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_AVERAGE_DET) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<MulOp <double> ,vr_rand_det<MulOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_AVERAGE_DET) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<MulOp <float> ,vr_rand_det<MulOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_AVERAGE_DET) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<DivOp <double> ,vr_rand_det<DivOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_AVERAGE_DET) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<DivOp <float> ,vr_rand_det<DivOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_AVERAGE_DET) (double a, double b, double c, double* res,void* context) {
  typedef RoundingAverage<MAddOp <double> ,vr_rand_det<MAddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_AVERAGE_DET) (float a, float b, float c, float* res,void* context) {
  typedef RoundingAverage<MAddOp <float> ,vr_rand_det<MAddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_AVERAGE_DET) (double a, float* res, void* context){
  typedef RoundingAverage<CastOp<double,float> ,vr_rand_det<CastOp <double,float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_AVERAGE_COMDET) (double a, double* res,void* context) {
  typedef RoundingAverage<SqrtOp <double> ,vr_rand_comdet<SqrtOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_AVERAGE_COMDET) (float a, float* res,void* context) {
  typedef RoundingAverage<SqrtOp <float> ,vr_rand_comdet<SqrtOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_AVERAGE_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<AddOp <double> ,vr_rand_comdet<AddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_AVERAGE_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<AddOp <float> ,vr_rand_comdet<AddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_AVERAGE_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<SubOp <double> ,vr_rand_comdet<SubOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_AVERAGE_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<SubOp <float> ,vr_rand_comdet<SubOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_AVERAGE_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<MulOp <double> ,vr_rand_comdet<MulOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_AVERAGE_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<MulOp <float> ,vr_rand_comdet<MulOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_AVERAGE_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingAverage<DivOp <double> ,vr_rand_comdet<DivOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_AVERAGE_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingAverage<DivOp <float> ,vr_rand_comdet<DivOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_AVERAGE_COMDET) (double a, double b, double c, double* res,void* context) {
  typedef RoundingAverage<MAddOp <double> ,vr_rand_comdet<MAddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_AVERAGE_COMDET) (float a, float b, float c, float* res,void* context) {
  typedef RoundingAverage<MAddOp <float> ,vr_rand_comdet<MAddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_AVERAGE_COMDET) (double a, float* res, void* context){
  typedef RoundingAverage<CastOp<double,float> ,vr_rand_comdet<CastOp <double,float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_AVERAGE_SCOMDET) (double a, double* res,void* context) {
  typedef RoundingSAverage<SqrtOp <double> ,vr_rand_scomdet<SqrtOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_AVERAGE_SCOMDET) (float a, float* res,void* context) {
  typedef RoundingSAverage<SqrtOp <float> ,vr_rand_scomdet<SqrtOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_AVERAGE_SCOMDET) (double a, double b, double* res,void* context) {
  typedef RoundingSAverage<AddOp <double> ,vr_rand_scomdet<AddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_AVERAGE_SCOMDET) (float a, float b, float* res,void* context) {
  typedef RoundingSAverage<AddOp <float> ,vr_rand_scomdet<AddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_AVERAGE_SCOMDET) (double a, double b, double* res,void* context) {
  typedef RoundingSAverage<SubOp <double> ,vr_rand_scomdet<SubOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_AVERAGE_SCOMDET) (float a, float b, float* res,void* context) {
  typedef RoundingSAverage<SubOp <float> ,vr_rand_scomdet<SubOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_AVERAGE_SCOMDET) (double a, double b, double* res,void* context) {
  typedef RoundingSAverage<MulOp <double> ,vr_rand_scomdet<MulOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_AVERAGE_SCOMDET) (float a, float b, float* res,void* context) {
  typedef RoundingSAverage<MulOp <float> ,vr_rand_scomdet<MulOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_AVERAGE_SCOMDET) (double a, double b, double* res,void* context) {
  typedef RoundingSAverage<DivOp <double> ,vr_rand_scomdet<DivOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_AVERAGE_SCOMDET) (float a, float b, float* res,void* context) {
  typedef RoundingSAverage<DivOp <float> ,vr_rand_scomdet<DivOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_AVERAGE_SCOMDET) (double a, double b, double c, double* res,void* context) {
  typedef RoundingSAverage<MAddOp <double> ,vr_rand_scomdet<MAddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_AVERAGE_SCOMDET) (float a, float b, float c, float* res,void* context) {
  typedef RoundingSAverage<MAddOp <float> ,vr_rand_scomdet<MAddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_AVERAGE_SCOMDET) (double a, float* res, void* context){
  typedef RoundingSAverage<CastOp<double,float> ,vr_rand_scomdet<CastOp <double,float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_PRANDOM) (double a, double* res,void* context) {
  typedef RoundingPRandom<SqrtOp <double> ,vr_rand_p<SqrtOp <double>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_PRANDOM) (float a, float* res,void* context) {
  typedef RoundingPRandom<SqrtOp <float> ,vr_rand_p<SqrtOp <float>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_PRANDOM) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<AddOp <double> ,vr_rand_p<AddOp <double>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_PRANDOM) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<AddOp <float> ,vr_rand_p<AddOp <float>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_PRANDOM) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<SubOp <double> ,vr_rand_p<SubOp <double>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_PRANDOM) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<SubOp <float> ,vr_rand_p<SubOp <float>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_PRANDOM) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<MulOp <double> ,vr_rand_p<MulOp <double>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_PRANDOM) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<MulOp <float> ,vr_rand_p<MulOp <float>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_PRANDOM) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<DivOp <double> ,vr_rand_p<DivOp <double>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_PRANDOM) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<DivOp <float> ,vr_rand_p<DivOp <float>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_PRANDOM) (double a, double b, double c, double* res,void* context) {
  typedef RoundingPRandom<MAddOp <double> ,vr_rand_p<MAddOp <double>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_PRANDOM) (float a, float b, float c, float* res,void* context) {
  typedef RoundingPRandom<MAddOp <float> ,vr_rand_p<MAddOp <float>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_PRANDOM) (double a, float* res, void* context){
  typedef RoundingPRandom<CastOp<double,float> ,vr_rand_p<CastOp <double,float>,vr_rand_prng> > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_PRANDOM_DET) (double a, double* res,void* context) {
  typedef RoundingPRandom<SqrtOp <double> ,vr_rand_p<SqrtOp <double>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_PRANDOM_DET) (float a, float* res,void* context) {
  typedef RoundingPRandom<SqrtOp <float> ,vr_rand_p<SqrtOp <float>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_PRANDOM_DET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<AddOp <double> ,vr_rand_p<AddOp <double>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_PRANDOM_DET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<AddOp <float> ,vr_rand_p<AddOp <float>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_PRANDOM_DET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<SubOp <double> ,vr_rand_p<SubOp <double>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_PRANDOM_DET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<SubOp <float> ,vr_rand_p<SubOp <float>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_PRANDOM_DET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<MulOp <double> ,vr_rand_p<MulOp <double>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_PRANDOM_DET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<MulOp <float> ,vr_rand_p<MulOp <float>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_PRANDOM_DET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<DivOp <double> ,vr_rand_p<DivOp <double>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_PRANDOM_DET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<DivOp <float> ,vr_rand_p<DivOp <float>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_PRANDOM_DET) (double a, double b, double c, double* res,void* context) {
  typedef RoundingPRandom<MAddOp <double> ,vr_rand_p<MAddOp <double>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_PRANDOM_DET) (float a, float b, float c, float* res,void* context) {
  typedef RoundingPRandom<MAddOp <float> ,vr_rand_p<MAddOp <float>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_PRANDOM_DET) (double a, float* res, void* context){
  typedef RoundingPRandom<CastOp<double,float> ,vr_rand_p<CastOp <double,float>,vr_rand_det> > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_PRANDOM_COMDET) (double a, double* res,void* context) {
  typedef RoundingPRandom<SqrtOp <double> ,vr_rand_p<SqrtOp <double>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_PRANDOM_COMDET) (float a, float* res,void* context) {
  typedef RoundingPRandom<SqrtOp <float> ,vr_rand_p<SqrtOp <float>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_PRANDOM_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<AddOp <double> ,vr_rand_p<AddOp <double>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_PRANDOM_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<AddOp <float> ,vr_rand_p<AddOp <float>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_PRANDOM_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<SubOp <double> ,vr_rand_p<SubOp <double>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_PRANDOM_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<SubOp <float> ,vr_rand_p<SubOp <float>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_PRANDOM_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<MulOp <double> ,vr_rand_p<MulOp <double>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_PRANDOM_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<MulOp <float> ,vr_rand_p<MulOp <float>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_PRANDOM_COMDET) (double a, double b, double* res,void* context) {
  typedef RoundingPRandom<DivOp <double> ,vr_rand_p<DivOp <double>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_PRANDOM_COMDET) (float a, float b, float* res,void* context) {
  typedef RoundingPRandom<DivOp <float> ,vr_rand_p<DivOp <float>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_PRANDOM_COMDET) (double a, double b, double c, double* res,void* context) {
  typedef RoundingPRandom<MAddOp <double> ,vr_rand_p<MAddOp <double>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_PRANDOM_COMDET) (float a, float b, float c, float* res,void* context) {
  typedef RoundingPRandom<MAddOp <float> ,vr_rand_p<MAddOp <float>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_PRANDOM_COMDET) (double a, float* res, void* context){
  typedef RoundingPRandom<CastOp<double,float> ,vr_rand_p<CastOp <double,float>,vr_rand_comdet> > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_double_SR_MONOTONIC) (double a, double* res,void* context) {
  typedef RoundingSRMonotonic<SqrtOp <double> ,vr_rand_det<SqrtOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sqrt_float_SR_MONOTONIC) (float a, float* res,void* context) {
  typedef RoundingSRMonotonic<SqrtOp <float> ,vr_rand_det<SqrtOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_double_SR_MONOTONIC) (double a, double b, double* res,void* context) {
  typedef RoundingSRMonotonic<AddOp <double> ,vr_rand_det<AddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(add_float_SR_MONOTONIC) (float a, float b, float* res,void* context) {
  typedef RoundingSRMonotonic<AddOp <float> ,vr_rand_det<AddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_double_SR_MONOTONIC) (double a, double b, double* res,void* context) {
  typedef RoundingSRMonotonic<SubOp <double> ,vr_rand_det<SubOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(sub_float_SR_MONOTONIC) (float a, float b, float* res,void* context) {
  typedef RoundingSRMonotonic<SubOp <float> ,vr_rand_det<SubOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_double_SR_MONOTONIC) (double a, double b, double* res,void* context) {
  typedef RoundingSRMonotonic<MulOp <double> ,vr_rand_det<MulOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(mul_float_SR_MONOTONIC) (float a, float b, float* res,void* context) {
  typedef RoundingSRMonotonic<MulOp <float> ,vr_rand_det<MulOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_double_SR_MONOTONIC) (double a, double b, double* res,void* context) {
  typedef RoundingSRMonotonic<DivOp <double> ,vr_rand_det<DivOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(div_float_SR_MONOTONIC) (float a, float b, float* res,void* context) {
  typedef RoundingSRMonotonic<DivOp <float> ,vr_rand_det<DivOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_double_SR_MONOTONIC) (double a, double b, double c, double* res,void* context) {
  typedef RoundingSRMonotonic<MAddOp <double> ,vr_rand_det<MAddOp <double> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(madd_float_SR_MONOTONIC) (float a, float b, float c, float* res,void* context) {
  typedef RoundingSRMonotonic<MAddOp <float> ,vr_rand_det<MAddOp <float> > > Op;
  *res=Op::apply(Op::PackArgs(a,b,c));
  
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}


IFV_INLINE void IFV_FCTNAME(cast_double_to_float_SR_MONOTONIC) (double a, float* res, void* context){
  typedef RoundingSRMonotonic<CastOp<double,float> ,vr_rand_det<CastOp <double,float> > > Op;
  *res=Op::apply(Op::PackArgs(a));
 
#ifndef VERROU_IGNORE_NANINF_CHECK
    if (isNanInf(*res)) {
      if(isNan(*res)){
	vr_nanHandler();
      }
      if(isinf(*res)){
	vr_infHandler();
      }
    }
#endif
;
}

