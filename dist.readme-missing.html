<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>5.Â README_MISSING_SYSCALL_OR_IOCTL</title>
<link rel="stylesheet" type="text/css" href="vg_basic.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="dist.html" title="Valgrind Distribution Documents">
<link rel="prev" href="dist.readme.html" title="4.Â README">
<link rel="next" href="dist.readme-developers.html" title="6.Â README_DEVELOPERS">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="dist.readme.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="dist.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">Valgrind Distribution Documents</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="dist.readme-developers.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="dist.readme-missing"></a>5.Â README_MISSING_SYSCALL_OR_IOCTL</h1></div></div></div>
<div class="literallayout"><p><br>
Â Â Â Â Â Â <br>
DealingÂ withÂ missingÂ systemÂ callÂ orÂ ioctlÂ wrappersÂ inÂ Valgrind<br>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>
You'reÂ probablyÂ readingÂ thisÂ becauseÂ ValgrindÂ bombedÂ outÂ whilst<br>
runningÂ yourÂ program,Â andÂ advisedÂ youÂ toÂ readÂ thisÂ file.Â Â TheÂ good<br>
newsÂ isÂ that,Â inÂ general,Â it'sÂ easyÂ toÂ writeÂ theÂ missingÂ syscallÂ or<br>
ioctlÂ wrappersÂ youÂ need,Â soÂ thatÂ youÂ canÂ continueÂ yourÂ debugging.Â Â If<br>
youÂ sendÂ theÂ resultingÂ patchesÂ toÂ me,Â thenÂ you'llÂ beÂ doingÂ aÂ favourÂ to<br>
allÂ futureÂ ValgrindÂ usersÂ too.<br>
<br>
NoteÂ thatÂ anÂ "ioctl"Â isÂ justÂ aÂ specialÂ kindÂ ofÂ systemÂ call,Â really;Â so<br>
there'sÂ notÂ aÂ lotÂ ofÂ needÂ toÂ distinguishÂ themÂ (atÂ leastÂ conceptually)<br>
inÂ theÂ discussionÂ thatÂ follows.<br>
<br>
AllÂ thisÂ machineryÂ isÂ inÂ coregrind/m_syswrap.<br>
<br>
<br>
WhatÂ areÂ syscall/ioctlÂ wrappers?Â Â WhatÂ doÂ theyÂ do?<br>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>
ValgrindÂ doesÂ whatÂ itÂ does,Â inÂ part,Â byÂ keepingÂ trackÂ ofÂ everythingÂ your<br>
programÂ does.Â Â WhenÂ aÂ systemÂ callÂ happens,Â forÂ exampleÂ aÂ requestÂ toÂ read<br>
partÂ ofÂ aÂ file,Â controlÂ passesÂ toÂ theÂ LinuxÂ kernel,Â whichÂ fulfillsÂ the<br>
request,Â andÂ returnsÂ controlÂ toÂ yourÂ program.Â Â TheÂ problemÂ isÂ thatÂ the<br>
kernelÂ willÂ oftenÂ changeÂ theÂ statusÂ ofÂ someÂ partÂ ofÂ yourÂ program'sÂ memory<br>
asÂ aÂ result,Â andÂ toolsÂ (instrumentationÂ plug-ins)Â mayÂ needÂ toÂ knowÂ about<br>
this.<br>
<br>
SyscallÂ andÂ ioctlÂ wrappersÂ haveÂ twoÂ jobs:Â <br>
<br>
1.Â TellÂ aÂ toolÂ what'sÂ aboutÂ toÂ happen,Â beforeÂ theÂ syscallÂ takesÂ place.Â Â A<br>
Â Â Â toolÂ couldÂ performÂ checksÂ beforehand,Â eg.Â ifÂ memoryÂ aboutÂ toÂ beÂ written<br>
Â Â Â isÂ actuallyÂ writeable.Â Â ThisÂ partÂ isÂ useful,Â butÂ notÂ strictly<br>
Â Â Â essential.<br>
<br>
2.Â TellÂ aÂ toolÂ whatÂ justÂ happened,Â afterÂ aÂ syscallÂ takesÂ place.Â Â ThisÂ is<br>
Â Â Â soÂ itÂ canÂ updateÂ itsÂ viewÂ ofÂ theÂ program'sÂ state,Â eg.Â thatÂ memoryÂ has<br>
Â Â Â justÂ beenÂ writtenÂ to.Â Â ThisÂ stepÂ isÂ essential.<br>
<br>
TheÂ "happenings"Â mostlyÂ involveÂ reading/writingÂ ofÂ memory.<br>
<br>
So,Â let'sÂ lookÂ atÂ anÂ exampleÂ ofÂ aÂ wrapperÂ forÂ aÂ systemÂ callÂ which<br>
shouldÂ beÂ familiarÂ toÂ manyÂ UnixÂ programmers.<br>
<br>
<br>
TheÂ syscallÂ wrapperÂ forÂ time()<br>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>
TheÂ wrapperÂ forÂ theÂ timeÂ systemÂ callÂ looksÂ likeÂ this:<br>
<br>
Â Â PRE(sys_time)<br>
Â Â {<br>
Â Â Â Â Â /*Â time_tÂ time(time_tÂ *t);Â */<br>
Â Â Â Â Â PRINT("sys_timeÂ (Â %pÂ )",ARG1);<br>
Â Â Â Â Â PRE_REG_READ1(long,Â "time",Â intÂ *,Â t);<br>
Â Â Â Â Â ifÂ (ARG1Â !=Â 0)Â {<br>
Â Â Â Â Â Â Â Â PRE_MEM_WRITE(Â "time(t)",Â ARG1,Â sizeof(vki_time_t)Â );<br>
Â Â Â Â Â }<br>
Â Â }<br>
<br>
Â Â POST(sys_time)<br>
Â Â {Â Â <br>
Â Â Â Â Â ifÂ (ARG1Â !=Â 0)Â {<br>
Â Â Â Â Â Â Â Â POST_MEM_WRITE(Â ARG1,Â sizeof(vki_time_t)Â );<br>
Â Â Â Â Â }<br>
Â Â }<br>
<br>
TheÂ firstÂ thingÂ weÂ doÂ happensÂ beforeÂ theÂ syscallÂ occurs,Â inÂ theÂ PRE()Â function.<br>
TheÂ PRE()Â functionÂ typicallyÂ startsÂ withÂ invokingÂ toÂ theÂ PRINT()Â macro.Â This<br>
PRINT()Â macroÂ implementsÂ supportÂ forÂ theÂ --trace-syscallsÂ commandÂ lineÂ option.<br>
Next,Â theÂ toolÂ isÂ toldÂ theÂ returnÂ typeÂ ofÂ theÂ syscall,Â thatÂ theÂ syscallÂ has<br>
oneÂ argument,Â theÂ typeÂ ofÂ theÂ syscallÂ argumentÂ andÂ thatÂ theÂ argumentÂ isÂ being<br>
readÂ fromÂ aÂ register:<br>
<br>
Â Â Â Â Â PRE_REG_READ1(long,Â "time",Â intÂ *,Â t);<br>
<br>
Next,Â ifÂ aÂ non-NULLÂ bufferÂ isÂ passedÂ inÂ asÂ theÂ argument,Â tellÂ theÂ toolÂ thatÂ the<br>
bufferÂ isÂ aboutÂ toÂ beÂ writtenÂ to:<br>
<br>
Â Â Â Â Â ifÂ (ARG1Â !=Â 0)Â {<br>
Â Â Â Â Â Â Â Â PRE_MEM_WRITE(Â "time",Â ARG1,Â sizeof(vki_time_t)Â );<br>
Â Â Â Â Â }<br>
<br>
Finally,Â theÂ reallyÂ importantÂ bit,Â afterÂ theÂ syscallÂ occurs,Â inÂ theÂ POST()<br>
function:Â Â if,Â andÂ onlyÂ if,Â theÂ systemÂ callÂ wasÂ successful,Â tellÂ theÂ toolÂ that<br>
theÂ memoryÂ wasÂ written:<br>
<br>
Â Â Â Â Â ifÂ (ARG1Â !=Â 0)Â {<br>
Â Â Â Â Â Â Â Â POST_MEM_WRITE(Â ARG1,Â sizeof(vki_time_t)Â );<br>
Â Â Â Â Â }<br>
<br>
TheÂ POST()Â functionÂ won'tÂ beÂ calledÂ ifÂ theÂ syscallÂ failed,Â soÂ you<br>
don'tÂ needÂ toÂ worryÂ aboutÂ checkingÂ thatÂ inÂ theÂ POST()Â function.<br>
(Note:Â thisÂ isÂ sometimesÂ aÂ bug;Â someÂ syscallsÂ doÂ returnÂ resultsÂ when<br>
theyÂ "fail"Â -Â forÂ example,Â nanosleepÂ returnsÂ theÂ amountÂ ofÂ unslept<br>
timeÂ ifÂ interrupted.Â TODO:Â addÂ anotherÂ per-syscallÂ flagÂ forÂ this<br>
case.)<br>
<br>
NoteÂ thatÂ weÂ useÂ theÂ typeÂ 'vki_time_t'.Â Â ThisÂ isÂ aÂ copyÂ ofÂ theÂ kernel<br>
type,Â withÂ 'vki_'Â prefixed.Â Â OurÂ copiesÂ ofÂ suchÂ typesÂ areÂ keptÂ inÂ the<br>
appropriateÂ vki*.hÂ file(s).Â Â WeÂ don'tÂ includeÂ kernelÂ headersÂ orÂ glibcÂ headers<br>
directly.<br>
<br>
<br>
WritingÂ yourÂ ownÂ syscallÂ wrappersÂ (seeÂ belowÂ forÂ ioctlÂ wrappers)<br>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>
IfÂ ValgrindÂ tellsÂ youÂ thatÂ systemÂ callÂ NNNÂ isÂ unimplemented,Â doÂ theÂ <br>
following:<br>
<br>
1.Â Â FindÂ outÂ theÂ nameÂ ofÂ theÂ systemÂ call:<br>
<br>
Â Â Â Â Â Â Â grepÂ NNNÂ /usr/include/asm/unistd*.h<br>
<br>
Â Â Â Â ThisÂ shouldÂ tellÂ youÂ somethingÂ likeÂ Â __NR_mysyscallname.<br>
Â Â Â Â CopyÂ thisÂ entryÂ toÂ include/vki/vki-scnums-$(VG_PLATFORM).h.<br>
<br>
Â Â Â Â IfÂ youÂ can'tÂ findÂ theÂ systemÂ callÂ inÂ /usr/include,Â tryÂ lookingÂ inÂ the<br>
Â Â Â Â straceÂ sourceÂ codeÂ (https://github.com/strace/strace).Â SomeÂ syscalls/ioctls<br>
Â Â Â Â areÂ notÂ definedÂ explicitly,Â butÂ straceÂ mayÂ haveÂ alreadyÂ figuredÂ itÂ out.<br>
<br>
<br>
2.Â Â DoÂ 'manÂ 2Â mysyscallname'Â toÂ getÂ someÂ ideaÂ ofÂ whatÂ theÂ syscall<br>
Â Â Â Â does.Â Â NoteÂ thatÂ theÂ actualÂ kernelÂ interfaceÂ canÂ differÂ fromÂ this,<br>
Â Â Â Â soÂ youÂ mightÂ alsoÂ wantÂ toÂ checkÂ aÂ versionÂ ofÂ theÂ LinuxÂ kernel<br>
Â Â Â Â source.<br>
<br>
Â Â Â Â NOTE:Â anyÂ syscallÂ whichÂ hasÂ somethingÂ toÂ doÂ withÂ signalsÂ or<br>
Â Â Â Â threadsÂ isÂ probablyÂ "special",Â andÂ needsÂ moreÂ carefulÂ handling.<br>
Â Â Â Â PostÂ somethingÂ toÂ valgrind-developersÂ ifÂ youÂ aren'tÂ sure.<br>
<br>
<br>
3.Â Â AddÂ aÂ caseÂ toÂ theÂ already-hugeÂ collectionÂ ofÂ wrappersÂ inÂ <br>
Â Â Â Â theÂ coregrind/m_syswrap/syswrap-*.cÂ files.Â <br>
Â Â Â Â ForÂ eachÂ in-memoryÂ parameterÂ whichÂ isÂ readÂ orÂ writtenÂ by<br>
Â Â Â Â theÂ syscall,Â doÂ oneÂ of<br>
Â Â Â Â <br>
Â Â Â Â Â Â PRE_MEM_READ(Â ...Â )<br>
Â Â Â Â Â Â PRE_MEM_RASCIIZ(Â ...Â )Â <br>
Â Â Â Â Â Â PRE_MEM_WRITE(Â ...Â )Â <br>
Â Â Â Â Â Â <br>
Â Â Â Â forÂ Â thatÂ parameter.Â Â ThenÂ doÂ theÂ syscall.Â Â Then,Â ifÂ theÂ syscall<br>
Â Â Â Â succeeds,Â issueÂ suitableÂ POST_MEM_WRITE(Â ...Â )Â calls.<br>
Â Â Â Â (There'sÂ noÂ needÂ forÂ POST_MEM_READÂ calls.)<br>
<br>
Â Â Â Â Also,Â addÂ itÂ toÂ theÂ syscall_table[]Â array;Â useÂ oneÂ ofÂ GENX_,Â GENXY<br>
Â Â Â Â LINX_,Â LINXY,Â PLAX_,Â PLAXY.<br>
Â Â Â Â GEN*Â forÂ genericÂ syscallsÂ (inÂ syswrap-generic.c),Â LIN*Â forÂ linux<br>
Â Â Â Â specificÂ onesÂ (inÂ syswrap-linux.c)Â andÂ PLA*Â forÂ theÂ platform<br>
Â Â Â Â dependentÂ onesÂ (inÂ syswrap-$(PLATFORM)-linux.c).<br>
Â Â Â Â TheÂ *XYÂ variantÂ ifÂ itÂ requiresÂ aÂ PRE()Â andÂ POST()Â function,Â and<br>
Â Â Â Â theÂ *X_Â variantÂ ifÂ itÂ onlyÂ requiresÂ aÂ PRE()<br>
Â Â Â Â function.Â Â <br>
Â Â Â Â <br>
Â Â Â Â IfÂ youÂ findÂ thisÂ difficult,Â readÂ theÂ wrappersÂ forÂ otherÂ syscalls<br>
Â Â Â Â forÂ ideas.Â Â AÂ goodÂ tipÂ isÂ toÂ lookÂ forÂ theÂ wrapperÂ forÂ aÂ syscall<br>
Â Â Â Â whichÂ hasÂ aÂ similarÂ behaviourÂ toÂ yours,Â andÂ useÂ itÂ asÂ aÂ <br>
Â Â Â Â startingÂ point.<br>
<br>
Â Â Â Â IfÂ youÂ needÂ structureÂ definitionsÂ and/orÂ constantsÂ forÂ yourÂ syscall,<br>
Â Â Â Â copyÂ themÂ fromÂ theÂ kernelÂ headersÂ intoÂ include/vki.hÂ andÂ co.,Â with<br>
Â Â Â Â theÂ appropriateÂ vki_*/VKI_*Â nameÂ mangling.Â Â Don'tÂ #includeÂ any<br>
Â Â Â Â kernelÂ headers.Â Â AndÂ certainlyÂ don'tÂ #includeÂ anyÂ glibcÂ headers.<br>
<br>
Â Â Â Â TestÂ it.<br>
<br>
Â Â Â Â NoteÂ thatÂ aÂ commonÂ errorÂ isÂ toÂ callÂ POST_MEM_WRITE(Â ...Â )<br>
Â Â Â Â withÂ 0Â (NULL)Â asÂ theÂ firstÂ (address)Â argument.Â Â ThisÂ usuallyÂ means<br>
Â Â Â Â yourÂ logicÂ isÂ slightlyÂ inadequate.Â Â It'sÂ aÂ sufficientlyÂ commonÂ bug<br>
Â Â Â Â thatÂ there'sÂ aÂ built-inÂ checkÂ forÂ it,Â andÂ you'llÂ getÂ aÂ "probably<br>
Â Â Â Â sanityÂ checkÂ failure"Â forÂ theÂ syscallÂ wrapperÂ youÂ justÂ made,Â ifÂ this<br>
Â Â Â Â isÂ theÂ case.<br>
<br>
<br>
4.Â Â OnceÂ happy,Â sendÂ usÂ theÂ patch.Â Â PrettyÂ please.<br>
<br>
<br>
<br>
<br>
WritingÂ yourÂ ownÂ ioctlÂ wrappers<br>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>
<br>
IsÂ prettyÂ muchÂ theÂ sameÂ asÂ writingÂ syscallÂ wrappers,Â exceptÂ thatÂ all<br>
theÂ actionÂ happensÂ withinÂ PRE(ioctl)Â andÂ POST(ioctl).<br>
<br>
There'sÂ aÂ defaultÂ case,Â sometimesÂ itÂ isn'tÂ correctÂ andÂ youÂ haveÂ toÂ writeÂ a<br>
moreÂ specificÂ caseÂ toÂ getÂ theÂ rightÂ behaviour.<br>
<br>
AsÂ above,Â pleaseÂ createÂ aÂ bugÂ reportÂ andÂ attachÂ theÂ patchÂ asÂ described<br>
onÂ http://www.valgrind.org.<br>
<br>
<br>
WritingÂ yourÂ ownÂ doorÂ callÂ wrappersÂ (SolarisÂ only)<br>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>
<br>
UnlikeÂ syscallsÂ orÂ ioctls,Â doorÂ callsÂ transferÂ dataÂ betweenÂ twoÂ userspace<br>
programs,Â albeitÂ throughÂ aÂ kernelÂ interface.Â ProgramsÂ mayÂ useÂ completely<br>
proprietaryÂ semanticsÂ inÂ theÂ dataÂ buffersÂ passedÂ betweenÂ them.<br>
ThereforeÂ itÂ mayÂ notÂ beÂ possibleÂ toÂ captureÂ theseÂ semanticsÂ within<br>
aÂ ValgrindÂ doorÂ callÂ orÂ doorÂ returnÂ wrapper.<br>
<br>
Nevertheless,Â forÂ systemÂ orÂ well-knownÂ doorÂ servicesÂ itÂ wouldÂ beÂ beneficial<br>
toÂ haveÂ aÂ doorÂ callÂ andÂ aÂ doorÂ returnÂ wrapper.Â WritingÂ suchÂ wrapperÂ isÂ pretty<br>
muchÂ theÂ sameÂ asÂ writingÂ ioctlÂ wrappers.Â PleaseÂ takeÂ aÂ fewÂ momentsÂ toÂ study<br>
theÂ followingÂ pictureÂ depictingÂ howÂ aÂ doorÂ clientÂ andÂ aÂ doorÂ serverÂ interact<br>
throughÂ theÂ kernelÂ interfaceÂ inÂ aÂ typicalÂ scenario:<br>
<br>
<br>
doorÂ clientÂ threadÂ Â Â Â Â Â Â Â Â Â kernelÂ Â Â Â Â Â Â doorÂ serverÂ thread<br>
invokesÂ door_call()Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â invokesÂ door_return()<br>
-------------------------------------------------------------------<br>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;----Â Â PRE(sys_door,Â DOOR_RETURN)<br>
PRE(sys_door,Â DOOR_CALL)Â Â ---&gt;<br>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ----&gt;Â Â POST(sys_door,Â DOOR_RETURN)<br>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ----&gt;Â server_procedure()<br>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;----<br>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;----Â Â PRE(sys_door,Â DOOR_RETURN)<br>
POST(sys_door,Â DOOR_CALL)Â &lt;---<br>
<br>
TheÂ firstÂ PRE(sys_door,Â DOOR_RETURN)Â isÂ invokedÂ withÂ data_ptr=NULL<br>
andÂ data_size=0.Â That'sÂ becauseÂ itÂ hasÂ notÂ receivedÂ anyÂ dataÂ from<br>
aÂ doorÂ call,Â yet.<br>
<br>
SemanticsÂ areÂ describedÂ byÂ theÂ followingÂ functions<br>
inÂ coregring/m_syswrap/syswrap-solaris.cÂ module:<br>
oÂ ForÂ aÂ doorÂ callÂ wrapperÂ theÂ followingÂ attributesÂ ofÂ 'params'Â argument:<br>
Â Â -Â data_ptrÂ (andÂ associatedÂ data_size)Â asÂ inputÂ bufferÂ (request);<br>
Â Â Â Â Â Â describedÂ inÂ door_call_pre_mem_params_data()<br>
Â Â -Â rbufÂ (andÂ associatedÂ rsize)Â asÂ outputÂ bufferÂ (response);<br>
Â Â Â Â Â Â describedÂ inÂ door_call_post_mem_params_rbuf()<br>
oÂ ForÂ aÂ doorÂ returnÂ wrapperÂ theÂ followingÂ parameters:<br>
Â Â -Â data_ptrÂ (andÂ associatedÂ data_size)Â asÂ inputÂ bufferÂ (request);<br>
Â Â Â Â Â Â describedÂ inÂ door_return_post_mem_data()<br>
Â Â -Â data_ptrÂ (andÂ associatedÂ data_size)Â asÂ outputÂ bufferÂ (response);<br>
Â Â Â Â Â Â describedÂ inÂ door_return_pre_mem_data()<br>
<br>
There'sÂ aÂ defaultÂ caseÂ whichÂ mayÂ notÂ beÂ correctÂ andÂ youÂ haveÂ toÂ writeÂ a<br>
moreÂ specificÂ caseÂ toÂ getÂ theÂ rightÂ behaviour.Â UnlessÂ Valgrind'sÂ option<br>
'--sim-hints=lax-doors'Â isÂ specified,Â theÂ defaultÂ caseÂ alsoÂ spitsÂ aÂ warning.<br>
<br>
AsÂ above,Â pleaseÂ createÂ aÂ bugÂ reportÂ andÂ attachÂ theÂ patchÂ asÂ described<br>
onÂ http://www.valgrind.org.<br>
<br>
Â Â Â Â </p></div>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="dist.readme.html">&lt;&lt;Â 4.Â README</a>Â </td>
<td width="20%" align="center"><a accesskey="u" href="dist.html">Up</a></td>
<td rowspan="2" width="40%" align="right">Â <a accesskey="n" href="dist.readme-developers.html">6.Â README_DEVELOPERSÂ &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
