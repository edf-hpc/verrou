<?xml version="1.0"?> <!-- -*- sgml -*- -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
          "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter id="vr-manual" xreflabel="Verrou">
  <title>Verrou: a floating-point rounding errors checker</title>

  <para>
    To use this tool, you must specify <option>--tool=verrou</option> on the
    Valgrind command line.
  </para>

  <xi:include href="vr-overview.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude" />

  <xi:include href="vr-std.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude" />

  <xi:include href="vr-scope.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude" />

  <xi:include href="vr-localization.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude" />


  <section id="vr-manual.advanced" xreflabel="Advanced features">
    <title>Advanced features</title>

    <section id="vr-manual.feat.deterministic" xreflabel="Deterministic sections">
      <title>Deterministic sections</title>
      <para>
        Sometimes you want a part of your program to be instrumented and perturbed by
        rounding-mode switches, but you don't want to lose determinism. For example, in
        the following program, <function>det</function> is called twice with the same
        arguments, and the correct execution relies on the strong hypothesis that both
        calls will return the same result.
      </para>

      <note>
	Before to use this option, you should think about to use the <computeroutput>_det</computeroutput>, <computeroutput>_comdet</computeroutput> or  <computeroutput>_scomdet</computeroutput> rounding modes (See <option><xref linkend="vr-opt.rounding-mode"/></option> option).
      </note>

      <programlisting>
double det (double x) {
  return 0.1*x;
}

int main () {
  double x1 = det (42);
  double x2 = det (42);
  assert (x1 == x2);
} </programlisting>

      <para>
        In this situation, you know that <function>det</function> can contain
        floating-point errors, which you want to quantify. However, you also know that
        whatever these errors, <function>det</function> will remain deterministic and
        the assertion only fails due to the instrumentation added by
        Verrou. The <computeroutput><xref linkend="vr-cr.start-deterministic"/></computeroutput>
        client request can help dealing with such problems.
      </para>

      <para>
        At the beginning of a deterministic section, the pseudo-random number generator
        (pRNG) used for random rounding mode switching is seeded with a new value. This
        value is computed deterministically from the location in the program source
        code. This ensures that each time the instrumented program enters the same
        deterministic section (same location in the source code), the pRNG is seeded
        with the same value, leading to the same sequence of rounding mode switches. The
        seed value also depends on the PID of the current process, so that different
        program executions lead to different results.
      </para>

      <section>
        <title>Basic usage</title>

        <para>
          Use the <computeroutput>VERROU_START_DETERMINISTIC(0)</computeroutput> client
          request to mark the beginning of a deterministic section. Similarly, put
          a <computeroutput>VERROU_STOP_DETERMINISTIC(0)</computeroutput> client request
          at the end of the deterministic section to go back to (pseudo-)random rounding
          mode switching.
        </para>

        <para>
          Here is an example instrumented program:
          <programlisting>
#include &lt;valgrind/verrou.h&gt;

double det (double x) {
  VERROU_START_DETERMINISTIC(0);
  double result = 0.1*x;
  VERROU_STOP_DETERMINISTIC(0);
  return result;
}

int main () {
  double x1 = det (42);
  double x2 = det (42);
  assert (x1 == x2);
} </programlisting>
          whose execution yields the following output:
          <screen>
--8523-- Entering deterministic section 70660: det() (deterministic.c:4)
--8523-- Leaving deterministic section: det() (deterministic.c:6)
--8523-- Entering deterministic section 70660: det() (deterministic.c:4)
--8523-- Leaving deterministic section: det() (deterministic.c:6) </screen>

          Here we can see that both calls to the <function>det()</function> functions used
          the same value to seed the pRNG (based on the client request location in the
          source).
        </para>
      </section>

      <section>
        <title>Advanced usage</title>

        <para>
          Assume the following program, in which two distinct deterministic sections are
          instrumented, but the client requests have been abstracted out in separate
          function calls (this is actually required for example for Fortran programs,
          which have to call a C function to issue client requests):

          <programlisting>
#include &lt;valgrind/verrou.h&gt;

void verrou_startDeterministic() {
  VERROU_START_DETERMINISTIC(0);
}

void verrou_stopDeterministic() {
  VERROU_STOP_DETERMINISTIC(0);
}

double det1 () {
  verrou_startDeterministic();
  /* ... */
  verrou_stopDeterministic();
}

double det2 () {
  verrou_startDeterministic();
  /* ... */
  verrou_stopDeterministic();
}

int main () {
  fprintf (stderr, "   det1\n");
  assert (det1() == det1());

  fprintf (stderr, "   det2\n");
  assert (det2() == det2());
} </programlisting>

          Executing this program in Verrou yields the following output:
          <screen>
det1
--2909-- Entering deterministic section 82435: verrou_startDeterministic() (deterministic2.c:4)
--2909-- Leaving deterministic section: verrou_stopDeterministic() (deterministic2.c:8)
--2909-- Entering deterministic section 82435: verrou_startDeterministic() (deterministic2.c:4)
--2909-- Leaving deterministic section: verrou_stopDeterministic() (deterministic2.c:8)
det2
--2909-- Entering deterministic section 82435: verrou_startDeterministic() (deterministic2.c:4)
--2909-- Leaving deterministic section: verrou_stopDeterministic() (deterministic2.c:8)
--2909-- Entering deterministic section 82435: verrou_startDeterministic() (deterministic2.c:4)
--2909-- Leaving deterministic section: verrou_stopDeterministic() (deterministic2.c:8) </screen>
          since the client requests are always issued from the same source location, the
          two deterministic sections are seeded with the same value.
        </para>

        <para>
          It is possible to give
          the <computeroutput>VERROU_START_DETERMINISTIC</computeroutput> a non-0 LEVEL
          argument to look at the source location of a calling function in the stack. In
          the case described above, replacing
          the <function>verrou_startDeterminisic</function>
          and <function>verrou_stopDeterministic</function> function definitions like
          this:
          <programlisting>
void verrou_startDeterministic() {
  VERROU_START_DETERMINISTIC(1);
}

void verrou_stopDeterministic() {
  VERROU_STOP_DETERMINISTIC(1);
} </programlisting>
          yields the following output:
          <screen>
det1
--4523-- Entering deterministic section 14298: det1() (deterministic2.c:12)
--4523-- Leaving deterministic section: det1() (deterministic2.c:14)
--4523-- Entering deterministic section 14298: det1() (deterministic2.c:12)
--4523-- Leaving deterministic section: det1() (deterministic2.c:14)
det2
--4523-- Entering deterministic section 65473: det() (deterministic2.c:18)
--4523-- Leaving deterministic section: det2() (deterministic2.c:20)
--4523-- Entering deterministic section 65473: det() (deterministic2.c:18)
--4523-- Leaving deterministic section: det2() (deterministic2.c:20) </screen>
          in which the pRNG is seeded using source locations one level up the stack from
          the client request.
        </para>
        <para>
          Since the source location is not needed to go back to (pseudo-)random rounding
          mode switching, the LEVEL argument
          to <computeroutput>VERROU_STOP_DETERMINISTIC</computeroutput> is only used for
          cosmetic and debug purposes.
        </para>
      </section>
    </section>
  </section>

  <section id="vr-manual.reference" xreflabel="Reference">
    <title>Reference</title>
    <section id="vr-manual.clo" xreflabel="Command-line options">
      <title>Command-line options</title>

      <section>
        <title>General options</title>
        <variablelist id="vr.opts.general.list">

          <varlistentry id="vr-opt.verbose" xreflabel="--vr-verbose">
            <term><option><![CDATA[--vr-verbose=<yes|no> [default=no]]]></option></term>
            <listitem><para>Toggle verbosity: prints messages for x387
                instructions and client requests.
            </para></listitem>
          </varlistentry>

          <varlistentry id="vr-opt.count-op" xreflabel="--count-op">
            <term><option><![CDATA[--count-op=<yes|no> [default=yes]]]></option></term>
            <listitem><para>
                Toggle <link linkend="vr-manual.feat.count">floating-point
                  operations counting</link>.
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.backend" xreflabel="--backend">
            <term><option><![CDATA[--backend=<verrou|mcaquad|checkdenorm> [default=verrou]]]></option></term>
            <listitem><para>
		Select the <computeroutput>verrou</computeroutput>, <computeroutput>mcaquad</computeroutput>
		or <computeroutput>checkdenorm</computeroutput>
		backend. <computeroutput>verrou</computeroutput>
		enables to perform several rounding mode (See <option><xref linkend="vr-opt.rounding-mode"/></option> option).
		<computeroutput>mcaquad</computeroutput> enables to perform MCA (Monte Carlo Arithmetics)
		based on extended precision in quad (See  <option><xref linkend="vr-opt.mca-mode"/></option>,
		<option><xref linkend="vr-opt.mca-precision-double"/></option> and  <option><xref linkend="vr-opt.mca-precision-float"/></option>  options).
		The integration of <computeroutput>mcaquad</computeroutput> backend in the frontend verrou
		is still considered as experimental. <computeroutput>checkdenorm</computeroutput> enables
		the <computeroutput>ftz</computeroutput> rounding-mode and the <computeroutput>--check-denorm</computeroutput> and <computeroutput>--cd-gen-file</computeroutput> options.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_BACKEND</command></para>

	    </listitem>
          </varlistentry>

        </variablelist>
      </section>

      <section>
        <title>Perturbation of floating-point operations</title>
        <variablelist id="vr.opts.instr.list">

          <varlistentry id="vr-opt.rounding-mode" xreflabel="--rounding-mode">
            <term><option><![CDATA[--rounding-mode=<random[|_det|_comdet|_scomdet]|average[|_det|_comdet|_scomdet]|prandom[|_det|_comdet]|sr_[s]monotonic|nearest|native|upward|downward|toward_zero|away_zero|farthest|float|ftz> [default=native]]]></option></term>
            <listitem>
              <para>
                Emulate the given <link linkend="vr-manual.feat.rounding-mode">rounding mode</link>
		for operations instrumented with the verrou backend. If
                this option is not provided, Verrou always rounds to the nearest
                floating-point. Supported rounding modes are:
              </para>
              <itemizedlist>
                <listitem><para>
                    <command>Stochastic rounding modes:</command>
		    <computeroutput>random</computeroutput>,
                    <computeroutput>average</computeroutput>,
		    <computeroutput>prandom</computeroutput>,
		    <computeroutput>random_det</computeroutput>,
                    <computeroutput>average_det</computeroutput>,
		    <computeroutput>prandom_det</computeroutput>,
		    <computeroutput>random_comdet</computeroutput>,
                    <computeroutput>average_comdet</computeroutput>,
		    <computeroutput>prandom_comdet</computeroutput>,
		    <computeroutput>random_scomdet</computeroutput>,
                    <computeroutput>average_scomdet</computeroutput>,
		    <computeroutput>sr_monotonic</computeroutput>,
		    <computeroutput>sr_smonotonic</computeroutput>.
                </para></listitem>
                <listitem><para>
                  <command>IEEE-754 rounding modes:</command>
                  <computeroutput>nearest</computeroutput>,
                  <computeroutput>upward</computeroutput>,
                  <computeroutput>downward</computeroutput>,
                  <computeroutput>toward_zero</computeroutput>.
                </para></listitem>
                <listitem><para>
                    <command>Other:</command>
		    <computeroutput>native</computeroutput>[default] (similar to nearest (maybe different with <option>--libm=instrumented</option>),
		    <computeroutput>away_zero</computeroutput>,
		    <computeroutput>farthest</computeroutput>,
		    <computeroutput>float</computeroutput>,
		    <computeroutput>ftz</computeroutput>(imply checkdenorm backend).
                </para></listitem>
              </itemizedlist>
	      <para>This option can be activated with the env variable <command>VERROU_ROUNDING_MODE</command>.</para>
            </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.libm" xreflabel="--libm">
	                  <term><option><![CDATA[--libm=<auto_exclude|manual_exclude|instrumented> [default=auto_exclude]]]></option></term>
            <listitem>
              <para>
		Define the behavior of verrou with libm.
              </para>
              <itemizedlist>
                <listitem><para>
                  <command>auto_exclude</command> : The libm exclusion is automatically detected thanks pattern detection. The library detected  are libm, vgpreload_verrou, interlibmath, libquadmath and libgcc_s. If you need to perturb libgcc_s, we will need to use libgcc_s.
                </para></listitem>
                <listitem><para>
                  <command>manual_exclude</command> : The automatic detection is ignored and the user has to define manually the exclusion thanks <command>--exclude</command> option. This option is useful if the pattern detection detect object you need to perturb.
                </para></listitem>
		<listitem><para>
                  <command>instrumented</command> : the interposition library Interlibmath is loaded. This option is valid only with verrou backend. This option imply implicitly the libm exclusion.
                </para></listitem>
              </itemizedlist>

	      <para>
		The option <command>instrumented</command> is not yet compatible with verrou_dd_sym and verrou_dd_line. When it will be the case, the default will switch from <command>auto_exclude</command>  to <command>instrumented</command>
	      </para>
            </listitem>
	  </varlistentry>
	  <varlistentry id="vr-opt.libm-noinst-rounding-mode" xreflabel="--libm-noinst-rounding-mode=">
            <term><option><![CDATA[--libm-noinst-rounding-mode==<native|nearest> [default=native]]]></option></term>
	      <para>
		Select the behavior of libm (when <option>--libm=instrumented</option> is activated) when libm function are not instrumented (thanks <option>--exclude</option> or <option>--source</option>) between <command>native</command> and <command>nearest</command>.
	      </para>

	      <para>This option can be activated with the env variable <command>VERROU_LIBM_NOINST_ROUNDING_MODE</command>.</para>

	  </varlistentry>
			  <varlistentry id="vr-opt.mca-mode" xreflabel="--mca-mode">
            <term><option><![CDATA[--mca-mode=<mca|rr|pb|ieee> [default=mca]]]></option></term>
            <listitem>
              <para>
                Emulate the given MCA mode for operations instrumented with the mcaquad backend. Supported mca modes are:
              </para>
              <itemizedlist>
                <listitem><para>
                  <command>mca : </command> <computeroutput>full mca</computeroutput> (default)
                </para></listitem>
                <listitem><para>
                  <command>rr : </command> <computeroutput> random rounding</computeroutput>
                </para></listitem>
		<listitem><para>
                  <command>pb : </command> <computeroutput> precision bounding</computeroutput>
                </para></listitem>
		<listitem><para>
                  <command>ieee : </command> <computeroutput> ieee (rounding to nearest)</computeroutput>
                </para></listitem>
              </itemizedlist>

	      <para> The mcaquad backend implementation come from Verificarlo : <ulink url="https://github.com/verificarlo/verificarlo"> More information on Verificalo github </ulink>
	      </para>
            </listitem>
          </varlistentry>
	  <varlistentry id="vr-opt.mca-precision-double" xreflabel="--mca-precision-double">
            <term><option><![CDATA[--mca-precision-double= [default=53]]]></option></term>
            <listitem>
              <para>
                Configure the magnitude of inexact function used by mcaquad backend for double operation.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_MCA_PRECISION_DOUBLE</command>.</para>

            </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.mca-precision-float" xreflabel="--mca-precision-float">
            <term><option><![CDATA[--mca-precision-float= [default=24]]]></option></term>
            <listitem>
              <para>
                Configure the magnitude of inexact function used by mcaquad backend for float operation.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_MCA_PRECISION_FLOAT</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.seed" xreflabel="--vr-seed">
            <term><option><![CDATA[--vr-seed=RNG_SEED [default=automatically generated]]]></option></term>
            <listitem>
              <para>If present, this option allows setting the seed of the
              pseudo-Random Number Generator used for the
		<command>random</command> or
		<command>average </command> <link linkend="vr-manual.feat.rounding-mode">rounding modes</link>.
		The same option can also be used to set the seed of the hash function used for the [p]random_[com]det and average_[com]det
		rounding mode.
		This helps reproducing the behavior of a program under Verrou.
              </para>
              <para>If this option is omitted, the pRNG is seeded with a value
              based on the current time and process id, so that it should change
              at each execution.</para>
	      <para>This option can be activated with the env variable <command>VERROU_SEED</command>.</para>
            </listitem>
          </varlistentry>


	  <varlistentry id="vr-manual.feat.updatepfunc" xreflabel="--prandom-update">
            <term><option><![CDATA[--prandom-update=func [default=none]]]></option></term>
            <listitem>
              <para>If present, this option the p-value of the prandom[|det|comdet] rounding mode is
		updated (with an uniform random selection between 0 and 1) at the beginning of each function call.
		Be careful the option is highly sensitive
		to the program compilation option. If each the update is inserted between each floating point
		operations the  <link linkend="vr-manual.feat.rounding-mode">prandom and random modes</link> are equivalent.
		</para>
		<para>This option can be activated with the env variable <command>VERROU_PRANDOM_UPDATE</command>.</para>
              </listitem>
          </varlistentry>

	    <varlistentry id="vr-manual.feat.updatepvalue" xreflabel="--prandom-pvalue">
            <term><option><![CDATA[--prandom-pvalue=P ]]></option></term>
            <listitem>
              <para>If present, this option the p-value of the prandom[|det|comdet] rounding mode is
		set to P instead of the random number between 0 and 1.
		If P is equal to 0., prandom and upward are equivalent.
		If P is equal to 1., prandom and downward are equivalent.
		If P is equal to .5, prandom and random are equivalent.
	      </para>
		<para>This option can be activated with the env variable <command>VERROU_PRANDOM_PVALUE</command>.</para>
              </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.instr" xreflabel="--vr-instr-">
            <term><option><![CDATA[--vr-instr=<add|sub|mul|div|mAdd|mSub|sqrt|conv> [default=all]]]></option></term>
            <listitem>
              <para>Toggle instrumentation of floating-point additions,
                subtractions, multiplications, divisions, fused multiply
                additions, fused multiply subtractions, square root, conversions (only double to float cast) respectively.
		This option can be set multiple times (or use "," to separate arguments) to instrument multiple types of
                operations.</para>
              <para>If this option is not provided, all supported operations
		types are instrumented.</para>
	      <para>This option can be activated with the env variable <command>VERROU_INSTR</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.instr-scalar" xreflabel="--vr-instr-scalar-">
            <term><option><![CDATA[--vr-instr-scalar=<yes|no> [default=no]]]></option></term>
            <listitem><para>
                Toggle instrumentation of x387 scalar instructions.
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.instr-llo" xreflabel="--vr-instr-llo-">
            <term><option><![CDATA[--vr-instr-llo=<yes|no> [default=yes]]]></option></term>
            <listitem><para>
                Toggle instrumentation of llo scalar instructions (cast and all fma instructions are considered as llo).
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.instr-vec" xreflabel="--vr-instr-vec-">
            <term><option><![CDATA[--vr-instr-vec<2,4,8>=<yes|no> [default=yes]]]></option></term>
            <listitem><para>
                Toggle instrumentation of vectorized instructions (number corresponds to the pack size)
            </para></listitem>
          </varlistentry>
	  <varlistentry id="vr-opt.instr-unk" xreflabel="--vr-instr-unk">
            <term><option><![CDATA[--vr-instr-unk=<yes|no> [default=yes]]]></option></term>
            <listitem><para>
                Toggle instrumentation of instructions with unknown vectorized status (fma is unvectorized in valgrind IR).
            </para></listitem>
          </varlistentry>

	      
	      <varlistentry id="vr-opt.instr-[flt|dbl]" xreflabel="--vr-instr-[flt|dbl]-">
            <term><option><![CDATA[--vr-instr-[flt|dbl]=<yes|no> [default=yes]]]></option></term>
            <listitem><para>
                Toggle instrumentation of float (or double) instructions.
              </para>
	    </listitem>
           </varlistentry>

	  </variablelist>
      </section>

      <section>
        <title>Restriction of instrumentation scope</title>
        <variablelist id="vr.opts.scope.list">

          <varlistentry id="vr-opt.instr-atstart" xreflabel="--instr-atstart">
            <term><option><![CDATA[--instr-atstart=<yes|no> [default=yes]]]></option></term>
            <listitem><para>Toggle <link linkend="vr-manual.feat.instr">instrumentation
                  state</link> on or off at program start. Useful in combination
                  with <link linkend="vr-cr.start-instrumentation">client
                  requests</link>.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_INSTR_ATSTART</command>.</para>
	    </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.exclude" xreflabel="--exclude">
            <term><option><![CDATA[--exclude=FILE]]></option></term>
            <listitem><para>Symbols listed
                in <computeroutput>FILE</computeroutput> will be
                left <link linkend="vr-manual.feat.exclude">uninstrumented</link>.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_EXCLUDE</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.gen-exclude" xreflabel="--gen-exclude">
            <term><option><![CDATA[--gen-exclude=FILE]]></option></term>
            <listitem>
              <para>Generate in <computeroutput>FILE</computeroutput> a list of
                all symbols (which contain perturbed floating point instruction)
		encountered during program execution. This is useful
                to build an <link linkend="vr-manual.feat.exclude">exclusion
                list</link>.</para>
              <para>In combination
              with <option><xref linkend="vr-opt.exclude"/></option>, only list
              symbols which were not already present in the provided exclusion
              list.</para>
              <para>
                WARNING: in order to generate a correct list, the whole binary
                (including symbols listed in the list provided
                using <option><xref linkend="vr-opt.exclude"/></option>) must be
                instrumented. When using
                both <option><xref linkend="vr-opt.gen-exclude"/></option>
                and <option><xref linkend="vr-opt.exclude"/></option>, it is
                advised to avoid perturbing rounding-modes
                using <option><xref linkend="vr-opt.rounding-mode"/><![CDATA[=nearest]]></option>.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_GEN_EXCLUDE</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.source" xreflabel="--source">
            <term><option><![CDATA[--source=FILE]]></option></term>
            <listitem><para>When this option is present, only instructions
                coming from <link linkend="vr-manual.feat.source">source code
                lines</link> listed in <computeroutput>FILE</computeroutput>
                are instrumented.</para>
	      <para>This option can be activated with the env variable <command>VERROU_SOURCE</command>.</para>
	    </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.warn-unknown-source" xreflabel="--warn-unknown-source">
            <term><option><![CDATA[--warn-unknown-source=FILE]]></option></term>
            <listitem><para> This option requires the use of <command>--source</command> option. When used, verrou generates warning for each line of code (which execute floating point operation) neither present in the FILE defined by <command>--source</command> option  nor in the FILE provided by <command>--warn-unknown-source</command> option.
	      </para>
	      <para>This option can be activated with the env variable <command>VERROU_WARN_UNKNOWN_SOURCE</command>.</para>
	    </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.gen-source" xreflabel="--gen-source">
            <term><option><![CDATA[--gen-source=FILE]]></option></term>
            <listitem>
              <para>Generate in <computeroutput>FILE</computeroutput> the list
                of all <link linkend="vr-manual.feat.source">source code
                  lines</link> (which contain perturbed floating point instruction)
		encountered during program execution.</para>
              <para>In combination with
                <option><xref linkend="vr-opt.source"/></option>, only list
                source code lines which were not already present in the provided
                list.</para>
	      <para>This option can be activated with the env variable <command>VERROU_GEN_SOURCE</command>.</para>
            </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.expect-clr" xreflabel="--expect-clr">
            <term><option><![CDATA[--expect-clr=EXPECT_FILE]]></option></term>
            <listitem>
              <para> When this option is present the expect script is read. This file
		defines the interaction between verrou and the stdout (<link linkend= "id.expect.format">See expect format</link>). The main idea behind this format is to apply client request action when a line match a MATCH or EXPECT line. A MATCH line can be match anytime, whereas the EXPECT lines are matched sequentially.</para>

	      <para>This option can be activated with the env variable <command>VERROU_EXPECT_CLR</command>.</para>
	    </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.output-expect-rep" xreflabel="--output-expect-rep">
            <term><option><![CDATA[--output-expect-rep=REP]]></option></term>
            <listitem>
              <para> Specify the repository of expect log file. By default the log file is
		<computeroutput>EXPECT_FILE.log-PID</computeroutput>. With this option it is <computeroutput>REP/expect.log-PID</computeroutput>. This option as also influence on the keys <computeroutput> dump-stdout:</computeroutput> and <computeroutput> dump-filtered-stdout:</computeroutput>of the <link linkend= "id.expect.format">expect format</link>).
	      </para>

	      <para>This option can be activated with the env variable <command>VERROU_OUTPUT_EXPECT_REP</command>.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section>
        <title>Coverage generation </title>
        <variablelist id="vr.opts.coverage.list">

          <varlistentry id="vr.opt.trace" xreflabel="--trace">
            <term><option><![CDATA[--trace=FILE]]></option></term>
            <listitem><para>
		Activate the <link linkend="vr-manual.localization.CovBB" >Basic Blocks Coverage</link> for the symbols specified in <computeroutput> FILE</computeroutput>.
            </para></listitem>
          </varlistentry>

	<varlistentry id="vr.opt.output-trace-rep" xreflabel="--output-trace-rep">
            <term><option><![CDATA[--output-trace-rep=REP]]></option></term>
            <listitem><para>
		Specify the <computeroutput>REP</computeroutput> directory for the trace output files.
            </para></listitem>
          </varlistentry>
	</variablelist>

      </section>

      <section>
        <title>Detection</title>
        <variablelist id="vr.opts.detection.list">

          <varlistentry id="vr.opt.check-nan" xreflabel="--check-nan">
            <term><option><![CDATA[--check-nan=<yes|no> [default=yes]]]></option></term>
              <listitem><para>
		  Activate NaN detection. NaN produces a valgrind error.
		  This functionality requires the verrou backend.
              </para></listitem>
            </varlistentry>

	    <varlistentry id="vr.opt.check-inf" xreflabel="--check-inf">
              <term><option><![CDATA[--check-inf=<yes|no> [default=yes]]]></option></term>
		<listitem><para>
		    Activate Inf detection. +/-Inf produces a valgrind error.
		    This functionality requires the verrou backend.
		</para></listitem>
              </varlistentry>

	  <varlistentry id="vr.opt.check-cancellation" xreflabel="--check-cancellation">
            <term><option><![CDATA[--check-cancellation=<yes|no> [default=no]]]></option></term>
            <listitem><para>
		Activate cancellation detection. Cancellation produces a valgrind error.
		This functionality is available for the verrou, mcaquad  and checkdenorm backends. The level
		of detected cancellations can be configured with  <option><xref linkend="vr.opt.cc-threshold-float"/></option> and
		<option><xref linkend="vr.opt.cc-threshold-double"/></option>.
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr.opt.cc-gen-file" xreflabel="--cc-gen-file">
            <term><option><![CDATA[--cc-gen-file=<FILE>]]></option></term>
            <listitem><para>
		Generate in <computeroutput>FILE </computeroutput> with the source format for each code source line which produces at least one cancellation.
		This functionality is available for verrou, mcaquad and checkdenorm backends. The level
		of detected cancellations can be configured with  <option><xref linkend="vr.opt.cc-threshold-float"/></option> and
		<option><xref linkend="vr.opt.cc-threshold-double"/></option>.
            </para></listitem>
          </varlistentry>


	  <varlistentry id="vr.opt.cc-threshold-float" xreflabel="--cc-threshold-float">
            <term><option><![CDATA[--cc-threshold-float=<integer> [default=24]]]></option></term>
            <listitem><para>
		Configure the cancellation detection threshold for float operations.
		Default value is still experimental and could have to change.
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr.opt.cc-threshold-double" xreflabel="--cc-threshold-double">
            <term><option><![CDATA[--cc-threshold-double=<integer> [default=40]]]></option></term>
            <listitem><para>
		Configure the cancellation  detection threshold for double operations.
		Default value is still experimental and could have to change.
            </para></listitem>
          </varlistentry>



	  <varlistentry id="vr.opt.check-denorm" xreflabel="--check-denorm">
            <term><option><![CDATA[--check-denorm=<yes|no> [default=no]]]></option></term>
            <listitem><para>
		Activate denormal number detection. Denormal number produced by floating point operation produces a valgrind error.
		This functionality is available for the checkdenorm backend.
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr.opt.cd-gen-file" xreflabel="--cd-gen-file">
            <term><option><![CDATA[--cd-gen-file=<FILE>]]></option></term>
            <listitem><para>
		Generate in <computeroutput>FILE </computeroutput> with the source format for each code source line which produces at least one denormal number.
		This functionality is available for checkdenorm backend.
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr.opt.float_max" xreflabel="--check-max-float">
            <term><option><![CDATA[--check-max-float=<yes|no> [default=no]]]></option></term>
            <listitem><para>
		Activate max float detection. This functionality is compatible only with verrou backend.
            </para></listitem>
          </varlistentry>

        </variablelist>
      </section>

      <section>
        <title>Performance optimization</title>
        <variablelist id="vr.opts.optim.list">
          <varlistentry id="vr.opt.unsafe-llo-optim" xreflabel="--vr-unsafe-llo-optim">
            <term><option><![CDATA[--vr-unsafe-llo-optim=<yes|no> [default=no]]]></option></term>
            <listitem><para>
		Activate faster instrumentation process but unsafe when binary mixes
		llo and vect instructions.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>

    <section id="vr-manual.client-requests" xreflabel="Verrou specific client requests">
      <title>Client requests</title>

      <para>Verrou provides the
        following <link linkend="manual-core-adv.clientreq">client
        requests</link> in the <filename>valgrind/verrou.h</filename>
        header.
      </para>

      <variablelist>

        <varlistentry id="vr-cr.display-counters"
                      xreflabel="VERROU_DISPLAY_COUNTERS">
          <term><computeroutput>VERROU_DISPLAY_COUNTERS</computeroutput></term>
          <listitem><para>Display the
              current <link linkend="vr-manual.feat.count">instructions
              counters</link>.</para></listitem>
        </varlistentry>

        <varlistentry id="vr-cr.start-instrumentation"
                      xreflabel="VERROU_START_INSTRUMENTATION">
          <term><computeroutput>VERROU_START_INSTRUMENTATION</computeroutput></term>
          <listitem><para>Start full
              Verrou <link linkend="vr-manual.feat.instr">instrumentation</link>
              (including rounding mode switching) if not already
              enabled.</para></listitem>
        </varlistentry>

        <varlistentry id="vr-cr.stop-instrumentation"
                      xreflabel="VERROU_STOP_INSTRUMENTATION">
          <term><computeroutput>VERROU_STOP_INSTRUMENTATION</computeroutput></term>
          <listitem><para>Stop full
              Verrou <link linkend="vr-manual.feat.instr">instrumentation</link>
              (don't switch rounding modes) if not already disabled.</para></listitem>
        </varlistentry>

        <varlistentry id="vr-cr.start-deterministic"
                      xreflabel="VERROU_START_DETERMINISTIC(LEVEL)">
          <term><computeroutput>VERROU_START_DETERMINISTIC(LEVEL)</computeroutput></term>
          <listitem><para>Start
              a <link linkend="vr-manual.feat.deterministic">deterministic
              section</link>, i.e. one in which floating point operations are
              perturbed, but in a deterministic way.</para></listitem>
        </varlistentry>

        <varlistentry id="vr-cr.stop-deterministic"
                      xreflabel="VERROU_STOP_DETERMINISTIC(LEVEL)">
          <term><computeroutput>VERROU_STOP_DETERMINISTIC(LEVEL)</computeroutput></term>
          <listitem><para>Stop
              a <link linkend="vr-manual.feat.deterministic">deterministic
              section</link>, i.e. resume rounding mode switching in a
              (pseudo-)random way.</para></listitem>
        </varlistentry>


	<varlistentry id="vr-cr.dump-cover"
                      xreflabel="VERROU_DUMP_COVER">
          <term><computeroutput>VERROU_DUMP_COVER</computeroutput></term>
          <listitem><para> If <computeroutput>--trace</computeroutput> option is activated, the client request generates a partial cover and return the index of the cover.</para></listitem>
        </varlistentry>


	<varlistentry id="vr-manual.feat.clrupdatep"
                      xreflabel="VERROU_PRANDOM_UPDATE">
          <term><computeroutput>VERROU_PRANDOM_UPDATE</computeroutput></term>
          <listitem><para> The p-value of prandom[|_det|_comdet] rounding mode is set to a new random value between 0 and 1.</para></listitem>
        </varlistentry>

	<varlistentry id="vr-manual.feat.clrupdatepvalue"
                      xreflabel="VERROU_PRANDOM_UPDATE_VALUE">
          <term><computeroutput>VERROU_PRANDOM_UPDATE_VALUE(floatStr)</computeroutput></term>
          <listitem><para>  The p-value of prandom[|_det|_comdet] rounding mode is set to <computeroutput>floatStr</computeroutput>.</para></listitem>
        </varlistentry>

      </variablelist>
    </section>

    <section id="id.expect.format" xreflabel="expect format">
      <title>Expect script</title>
      <para>
	The expect script is activated thanks the option <option><xref linkend="vr-opt.expect-clr"/>=EXPECT_FILE</option>.
	The comment symbol is <computeroutput>#</computeroutput>.
	The format is divided in two parts. The first one is called <replaceable>headers</replaceable> and the second one <replaceable>temporal part</replaceable>.
	The two parts are separated by a key <computeroutput>begin:</computeroutput>.


      </para>
      <para>
      The <replaceable>header part</replaceable> can contain the configuration keys :
      <variablelist>
	<varlistentry>
	  <term><computeroutput>verbose: LEVEL</computeroutput></term>
	  <listitem>
	    Configure the verbosity level (default 1)
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>ignore-empty-line:</computeroutput></term>
	  <listitem>
	    If this key is present, the empty lines are ignored.
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>filter_line_exec: CMD</computeroutput></term>
	  <listitem>
	    Activate the line replacement with CMD.
	  </listitem>

	  <para>
	  The first argument of <computeroutput>CMD</computeroutput> has to be a path absolute (or relative if there is no CWD change). This option is not (yet) able to read the <computeroutput>$PATH</computeroutput> env variable. All the space are used to separate command arguments. To prevent this behaviour, the only way is to escape the space by a backslash.	  </para>

	   <para>
	     If there are two many calls to this command (ie. too many line in stdout), there are a known bug. You can detected with the valgrind Warning like this one:<programlisting>--20481-- warning: Unable to record PID of internal process (pipe)</programlisting>
</para>

	</varlistentry>

	<varlistentry>
	  <term><computeroutput>dump-stdout: [FILENAME]</computeroutput></term>
	  <listitem>
	    Dump the stdout file. If FILENAME is not set the default name is <computeroutput>EXPECT_FILE.stdout-PID</computeroutput> or <computeroutput>EXPECT_OUTPUT_REP/expect.stdout-PID</computeroutput> (if option <option>--output-expect-rep=EXPECT_OUTPUT_REP</option> is used). Remark: <computeroutput>FILENAME</computeroutput> absolute path and <option>--output-expect-rep=</option> are incompatible.
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>dump-filtered-stdout: [FILENAME]</computeroutput></term>
	  <listitem>
	    Dump the stdout file after application of <computeroutput>filter_line_exec CMD</computeroutput> to each line.
	     If FILENAME is not set the default name is <computeroutput>EXPECT_FILE.filtered.stdout-PID</computeroutput> or <computeroutput>EXPECT_OUTPUT_REP/expect.filtered.stdout-PID</computeroutput> (if option <option>--output-expect-rep=EXPECT_OUTPUT_REP</option> is used). Remark: <computeroutput>FILENAME</computeroutput> absolute path and <option>--output-expect-rep=</option> are incompatible.
	  </listitem>
	</varlistentry>
      </variablelist>

      </para>
      <para>
	In the <replaceable>header part</replaceable> we can also set up action to each section.
	<variablelist>
	<varlistentry>
	  <term><computeroutput>default: ACTION</computeroutput></term>
	  <listitem>
	    Add ACTION to the default section.
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>init: ACTION</computeroutput></term>
	  <listitem>
	    Add ACTION to the init section. This action will be executed during the verrou initialization.
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>post-init: ACTION</computeroutput></term>
	  <listitem>
	    Add ACTION to the post-init section. This action will be executed when the first stdout line appears.
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>match: PATTERN</computeroutput></term>
	  <listitem>
	    Setup a  match section. <computeroutput>PATTERN</computeroutput> is a wildcard expression with * and ?. The first space after :
	    is a part of the format. Every space after this one is meaningful. The order of match section is important.
	    If the first match is *. All following match section are ignored. The action associated to the section are
	    defined in the following lines by <computeroutput>apply:</computeroutput> and <computeroutput>post-apply:</computeroutput>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>apply: ACTION</computeroutput></term>
	  <listitem>
	    Add the ACTION to current <computeroutput>match</computeroutput> section. This action will be applied to the beginning of the match section.
	    If no action is set for a match section, the default group of action will be executed. To avoid the default action, you can use a
	    <computeroutput>nop</computeroutput> action.
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>post-apply: ACTION</computeroutput></term>
	  <listitem>
	    Add the ACTION to current <computeroutput>match</computeroutput> section. This action will be applied to the end of the match section.
	    If no post-action is defined, nothing is done (ie. no <computeroutput>default</computeroutput> action).
	  </listitem>
	</varlistentry>
      </variablelist>
      </para>

      <para>
The different possible actions are :
      <variablelist>
	<varlistentry>
	  <term><computeroutput>start</computeroutput></term>
	  <listitem> Start instrumentation.
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>stop</computeroutput></term>
	  <listitem>
	    Stop instrumentation.
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>nop</computeroutput></term>
	  <listitem>
	    do nothing (useful to avoid default action)
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>display_counter</computeroutput></term>
	  <listitem>
	    display counters
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>nb_instr</computeroutput></term>
	  <listitem>
	    Display the number of instrumented floating point operation in the log file.
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>reset_counter</computeroutput></term>
	  <listitem>
	    Set all floating point counters to zero.
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>dump_cover</computeroutput></term>
	  <listitem>
	    Apply <computeroutput>DUMP_COVER</computeroutput> client request.
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>panic</computeroutput></term>
	  <listitem>
	    Stop program with panic.
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>exit</computeroutput></term>
	  <listitem>
	    Stop program with exit.
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>default,init,post-init</computeroutput></term>
	  <listitem>
	    Apply the same group of actions defined for the section <computeroutput>default</computeroutput>, <computeroutput>init</computeroutput> and <computeroutput>post-init</computeroutput>.
	  </listitem>
	</varlistentry>

      </variablelist>

      </para>
      In the <replaceable>temporal part</replaceable> (after <computeroutput>begin:</computeroutput> key) the following keys can be defined:
      <variablelist>
	<varlistentry>
	  <term><computeroutput>except: PATTERN</computeroutput></term>
	  <listitem>
	    Define the pattern of the except line. As for <computeroutput>match: </computeroutput>,  <computeroutput>PATTERN</computeroutput> is a wildcard expression (with * and ?).
	    The actions associated are defined by the <computeroutput>apply:</computeroutput> key.
	  </listitem>
	</varlistentry>
	  <varlistentry>
	  <term><computeroutput>apply: ACTION</computeroutput></term>
	  <listitem>
	    Add the ACTION to current <computeroutput>expect</computeroutput> section. If no <computeroutput>apply:</computeroutput> key is defined, the default actions are executed.
	  </listitem>
	</varlistentry>
    </variablelist>

      <para>
	Remarks:
	<variablelist>
	  <varlistentry>
	    <listitem>
	     1) <computeroutput>expect:</computeroutput>key are more difficult to use than <computeroutput>match:</computeroutput>. Indeed if a pattern is not found, we will wait the end of the program without taking into account any following <computeroutput>expect:</computeroutput> key. But the temporal aspect of expect, allows sometimes to apply action by taking into account a context (by example the content of the previous line).
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <listitem>
	      2) If a line match the current expect, the match actions won't be applied.
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <listitem>
	      3) It is not possible to define <computeroutput>post-apply</computeroutput> action with <computeroutput>expect:</computeroutput>.
	    </listitem>
	  </varlistentry>
	</variablelist>

      </para>
    </section>

    <section>
      <title>Monitor commands</title>

      See <xref linkend="manual-core-adv.gdbserver"/> to get more information
      about the Valgrind gdbserver and monitor commands. Below is a list of
      specific monitor commands provided by Verrou:
      <variablelist>
        <varlistentry id="vr.monitor_count" xreflabel="count">
          <term><computeroutput>count</computeroutput></term>
          <listitem><para>Display the
              current <link linkend="vr-manual.feat.count">instructions
                counters</link>.
          </para></listitem>
        </varlistentry>
        <varlistentry id="vr.monitor_instrumentation" xreflabel="instrumentation">
          <term><computeroutput>instrumentation [on|off]</computeroutput></term>
          <listitem><para> Set the
              current <link linkend="vr-manual.feat.instr">instrumentation
              state</link> (or print it if
              no <computeroutput>on</computeroutput>
              / <computeroutput>off</computeroutput> parameter is given).
          </para></listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
</chapter>
