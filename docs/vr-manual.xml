<?xml version="1.0"?> <!-- -*- sgml -*- -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
          "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter id="vr-manual" xreflabel="Verrou">
  <title>Verrou: a floating-point rounding errors checker</title>

  <para>
    To use this tool, you must specify <option>--tool=verrou</option> on the
    Valgrind command line.
  </para>

  <xi:include href="vr-overview.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude" />

  <xi:include href="vr-std.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude" />

  <xi:include href="vr-scope.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude" />

  <xi:include href="vr-localization.xml"
              xmlns:xi="http://www.w3.org/2001/XInclude" />


  <section id="vr-manual.advanced" xreflabel="Advanced features">
    <title>Advanced features</title>

    <section id="vr-manual.feat.deterministic" xreflabel="Deterministic sections">
      <title>Deterministic sections</title>
      <para>
        Sometimes you want a part of your program to be instrumented and perturbed by
        rounding-mode switches, but you don't want to lose determinism. For example, in
        the following program, <function>det</function> is called twice with the same
        arguments, and the correct execution relies on the strong hypothesis that both
        calls will return the same result.
      </para>

      <note><para>
	Before to use this option, you should think about to use the <computeroutput>_det</computeroutput>, <computeroutput>_comdet</computeroutput> or  <computeroutput>_scomdet</computeroutput> rounding modes (See <xref linkend="vr-opt.rounding-mode"/> option).
      </para></note>

      <programlisting>
double det (double x) {
  return 0.1*x;
}

int main () {
  double x1 = det (42);
  double x2 = det (42);
  assert (x1 == x2);
} </programlisting>

      <para>
        In this situation, you know that <function>det</function> can contain
        floating-point errors, which you want to quantify. However, you also know that
        whatever these errors, <function>det</function> will remain deterministic and
        the assertion only fails due to the instrumentation added by
        Verrou. The <xref linkend="vr-cr.start-deterministic"/>
        client request can help dealing with such problems.
      </para>

      <para>
        At the beginning of a deterministic section, the pseudo-random number generator
        (pRNG) used for random rounding mode switching is seeded with a new value. This
        value is computed deterministically from the location in the program source
        code. This ensures that each time the instrumented program enters the same
        deterministic section (same location in the source code), the pRNG is seeded
        with the same value, leading to the same sequence of rounding mode switches. The
        seed value also depends on the PID of the current process, so that different
        program executions lead to different results.
      </para>

      <section>
        <title>Basic usage</title>

        <para>
          Use the <computeroutput>VERROU_START_DETERMINISTIC(0)</computeroutput> client
          request to mark the beginning of a deterministic section. Similarly, put
          a <computeroutput>VERROU_STOP_DETERMINISTIC(0)</computeroutput> client request
          at the end of the deterministic section to go back to (pseudo-)random rounding
          mode switching.
        </para>

        <para>
          Here is an example instrumented program:
          <programlisting>
#include &lt;valgrind/verrou.h&gt;

double det (double x) {
  VERROU_START_DETERMINISTIC(0);
  double result = 0.1*x;
  VERROU_STOP_DETERMINISTIC(0);
  return result;
}

int main () {
  double x1 = det (42);
  double x2 = det (42);
  assert (x1 == x2);
} </programlisting>
          whose execution yields the following output:
          <screen>
--8523-- Entering deterministic section 70660: det() (deterministic.c:4)
--8523-- Leaving deterministic section: det() (deterministic.c:6)
--8523-- Entering deterministic section 70660: det() (deterministic.c:4)
--8523-- Leaving deterministic section: det() (deterministic.c:6) </screen>

          Here we can see that both calls to the <function>det()</function> functions used
          the same value to seed the pRNG (based on the client request location in the
          source).
        </para>
      </section>

      <section>
        <title>Advanced usage</title>

        <para>
          Assume the following program, in which two distinct deterministic sections are
          instrumented, but the client requests have been abstracted out in separate
          function calls (this is actually required for example for Fortran programs,
          which have to call a C function to issue client requests):

          <programlisting>
#include &lt;valgrind/verrou.h&gt;

void verrou_startDeterministic() {
  VERROU_START_DETERMINISTIC(0);
}

void verrou_stopDeterministic() {
  VERROU_STOP_DETERMINISTIC(0);
}

double det1 () {
  verrou_startDeterministic();
  /* ... */
  verrou_stopDeterministic();
}

double det2 () {
  verrou_startDeterministic();
  /* ... */
  verrou_stopDeterministic();
}

int main () {
  fprintf (stderr, "   det1\n");
  assert (det1() == det1());

  fprintf (stderr, "   det2\n");
  assert (det2() == det2());
} </programlisting>

          Executing this program in Verrou yields the following output:
          <screen>
det1
--2909-- Entering deterministic section 82435: verrou_startDeterministic() (deterministic2.c:4)
--2909-- Leaving deterministic section: verrou_stopDeterministic() (deterministic2.c:8)
--2909-- Entering deterministic section 82435: verrou_startDeterministic() (deterministic2.c:4)
--2909-- Leaving deterministic section: verrou_stopDeterministic() (deterministic2.c:8)
det2
--2909-- Entering deterministic section 82435: verrou_startDeterministic() (deterministic2.c:4)
--2909-- Leaving deterministic section: verrou_stopDeterministic() (deterministic2.c:8)
--2909-- Entering deterministic section 82435: verrou_startDeterministic() (deterministic2.c:4)
--2909-- Leaving deterministic section: verrou_stopDeterministic() (deterministic2.c:8) </screen>
          since the client requests are always issued from the same source location, the
          two deterministic sections are seeded with the same value.
        </para>

        <para>
          It is possible to give
          the <computeroutput>VERROU_START_DETERMINISTIC</computeroutput> a non-0 LEVEL
          argument to look at the source location of a calling function in the stack. In
          the case described above, replacing
          the <function>verrou_startDeterminisic</function>
          and <function>verrou_stopDeterministic</function> function definitions like
          this:
          <programlisting>
void verrou_startDeterministic() {
  VERROU_START_DETERMINISTIC(1);
}

void verrou_stopDeterministic() {
  VERROU_STOP_DETERMINISTIC(1);
} </programlisting>
          yields the following output:
          <screen>
det1
--4523-- Entering deterministic section 14298: det1() (deterministic2.c:12)
--4523-- Leaving deterministic section: det1() (deterministic2.c:14)
--4523-- Entering deterministic section 14298: det1() (deterministic2.c:12)
--4523-- Leaving deterministic section: det1() (deterministic2.c:14)
det2
--4523-- Entering deterministic section 65473: det() (deterministic2.c:18)
--4523-- Leaving deterministic section: det2() (deterministic2.c:20)
--4523-- Entering deterministic section 65473: det() (deterministic2.c:18)
--4523-- Leaving deterministic section: det2() (deterministic2.c:20) </screen>
          in which the pRNG is seeded using source locations one level up the stack from
          the client request.
        </para>
        <para>
          Since the source location is not needed to go back to (pseudo-)random rounding
          mode switching, the LEVEL argument
          to <computeroutput>VERROU_STOP_DETERMINISTIC</computeroutput> is only used for
          cosmetic and debug purposes.
        </para>
      </section>
    </section>
  </section>

  <section id="vr-manual.reference" xreflabel="Reference">
    <title>Reference</title>
    <section id="vr-manual.clo" xreflabel="Command-line options">
      <title>Command-line options</title>

      <section>
        <title>General options</title>
        <variablelist id="vr.opts.general.list">

          <varlistentry id="vr-opt.verbose" xreflabel="--vr-verbose">
            <term><option><![CDATA[--vr-verbose=<yes|no> [default=no]]]></option></term>
            <listitem><para>Toggle verbosity: prints messages for x387
                instructions and client requests.
            </para></listitem>
          </varlistentry>

          <varlistentry id="vr-opt.count-op" xreflabel="--count-op">
            <term><option><![CDATA[--count-op=<yes|no> [default=yes]]]></option></term>
            <listitem><para>
                Toggle <link linkend="vr-manual.feat.count">floating-point
                  operations counting</link>.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_COUNT_OP</command></para>
	    </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.backend" xreflabel="--backend">
            <term><option><![CDATA[--backend=<verrou|mcaquad|checkdenorm> [default=verrou]]]></option></term>
            <listitem><para>
		Select the <computeroutput>verrou</computeroutput>, <computeroutput>mcaquad</computeroutput>
		or <computeroutput>checkdenorm</computeroutput>
		backend. <computeroutput>verrou</computeroutput>
		enables to perform several rounding mode (See <xref linkend="vr-opt.rounding-mode"/> option).
		<computeroutput>mcaquad</computeroutput> enables to perform MCA (Monte Carlo Arithmetics)
		based on extended precision in quad (See <xref linkend="vr-opt.mca-mode"/>,
		<xref linkend="vr-opt.mca-precision-double"/> and  <xref linkend="vr-opt.mca-precision-float"/>  options).
		The integration of <computeroutput>mcaquad</computeroutput> backend in the frontend verrou
		is still considered as experimental. <computeroutput>checkdenorm</computeroutput> enables
		the <computeroutput>daz,ftz,dazftz</computeroutput> rounding-modes, and the <computeroutput>--check-denorm</computeroutput> and <computeroutput>--cd[io]-gen-file</computeroutput> options.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_BACKEND</command></para>

	    </listitem>
          </varlistentry>

        </variablelist>
      </section>

      <section>
        <title>Perturbation of floating-point operations</title>
        <variablelist id="vr.opts.instr.list">

          <varlistentry id="vr-opt.rounding-mode" xreflabel="--rounding-mode">
            <term><option><![CDATA[--rounding-mode=<random[|_det|_comdet|_scomdet]|average[|_det|_comdet|_scomdet]|prandom[|_det|_comdet]|sr_[s]monotonic|nearest|native|upward|downward|toward_zero|away_zero|farthest|float|daz|ftz|dazftz> [default=native]]]></option></term>
            <listitem>
              <para>
                Emulate the given <link linkend="vr-manual.feat.rounding-mode">rounding mode</link>
		for operations instrumented with the verrou backend. If
                this option is not provided, Verrou always rounds to the nearest
                floating-point. Supported rounding modes are:
              </para>
              <itemizedlist>
                <listitem><para>
                    <command>Stochastic rounding modes:</command>
		    <computeroutput>random</computeroutput>,
                    <computeroutput>average</computeroutput>,
		    <computeroutput>prandom</computeroutput>,
		    <computeroutput>random_det</computeroutput>,
                    <computeroutput>average_det</computeroutput>,
		    <computeroutput>prandom_det</computeroutput>,
		    <computeroutput>random_comdet</computeroutput>,
                    <computeroutput>average_comdet</computeroutput>,
		    <computeroutput>prandom_comdet</computeroutput>,
		    <computeroutput>random_scomdet</computeroutput>,
                    <computeroutput>average_scomdet</computeroutput>,
		    <computeroutput>sr_monotonic</computeroutput>,
		    <computeroutput>sr_smonotonic</computeroutput>.
                </para></listitem>
                <listitem><para>
                  <command>IEEE-754 rounding modes:</command>
                  <computeroutput>nearest</computeroutput>,
                  <computeroutput>upward</computeroutput>,
                  <computeroutput>downward</computeroutput>,
                  <computeroutput>toward_zero</computeroutput>.
                </para></listitem>
		<listitem><para>
		    <command>Denormalized rounding modes (imply checkdenorm backend):</command>
		    <computeroutput>daz</computeroutput>,
		    <computeroutput>ftz</computeroutput>,
		    <computeroutput>dazftz</computeroutput>.
		    </para>
		</listitem>
                <listitem><para>
                    <command>Other:</command>
		    <computeroutput>native</computeroutput>[default] (similar to nearest (maybe different with <option>--libm=instrumented</option>),
		    <computeroutput>away_zero</computeroutput>,
		    <computeroutput>farthest</computeroutput>,
		    <computeroutput>float</computeroutput>,
                </para></listitem>
              </itemizedlist>
	      <para>This option can be activated with the env variable <command>VERROU_ROUNDING_MODE</command>.</para>
            </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.float" xreflabel="--float">
	    <term><option><![CDATA[--float=<yes|no> [default=no]]]></option></term>
	      <listitem>
		<para>
		  With this option, all double precision floating-point
		  operations are replaced by simple precision equivalent
		  in the frontend. Hence this option is compatible with all <option>--rounding-mode</option> options and with all other backends.
		</para>
		<itemizedlist>
		  <listitem><para>
		      Numerically, option <option>--rounding-mode=float</option> is equivalent to  <option>--rounding-mode=nearest --float=yes</option>.
		  </para></listitem>

		  <listitem><para>
		      Options <option>--rounding-mode=nearest --float=yes</option> instrument float operations by nearest wrapper function. So if your code contains float operations, it can be
		      useful to use <link linkend="vr-opt.instr-TYPE">--vr-instr-float=no</link> to speed up the instrumentation. The only drawback of this approach, is the deactivation of checks (such as Nan and Inf checks) over float operations.
		  </para></listitem>

		</itemizedlist>
		<para>This option can be activated with the env variable <command>VERROU_FLOAT</command>.</para>

	      </listitem>
	    </varlistentry>
	    <varlistentry id="vr-opt.unfused" xreflabel="--unfused">
	      <term><option><![CDATA[--unfused=<yes|no> [default=no]]]></option></term>
		<listitem>
		  <para>
		    With this option, mAdd (mSub resp.) operations are replaced by a Mul and a Add (resp. Sub) 
		    in the frontend. Hence this option is compatible with all <option>--rounding-mode</option> options and with all other backends.
		  </para>
		  <itemizedlist>
		    <listitem><para>
			The fma function of libm is not modified.
		    </para></listitem>
		    <listitem><para>
			Used with the nearest rounding mode, it is ofen pertinent to add the option 
			 <link linkend="vr-opt.instr"><option>--vr-instr=mAdd,mSub</option></link> to speed up the instrumentation. The only drawback of this approach, is the deactivation of checks (such as Nan and Inf checks) over other floating point operations.
		    </para></listitem>
		  </itemizedlist>
		  <para>This option can be activated with the env variable <command>VERROU_UNFUSED</command>.</para>

		</listitem>
	      </varlistentry>
	      <varlistentry id="vr-opt.python" xreflabel="--python">
	        <term><option><![CDATA[--python=<auto_exclude|manual_exclude> [default=auto_exclude]]]></option></term>
            <listitem>
              <para>
		Define the behavior of verrou with python.
              </para>
              <itemizedlist>
                <listitem><para>
                  <command>auto_exclude</command> : The default python exclusion list is activated.
                </para></listitem>
                <listitem><para>
                    <command>manual_exclude</command> : The default python exclusion list is ignored. The user has to manually define his own list.
                </para></listitem>
              </itemizedlist>
            </listitem>
		</varlistentry>
	      <varlistentry id="vr-opt.libm" xreflabel="--libm">
	        <term><option><![CDATA[--libm=<auto_exclude|manual_exclude|instrumented> [default=auto_exclude]]]></option></term>
            <listitem>
              <para>
		Define the behavior of verrou with libm.
              </para>
              <itemizedlist>
                <listitem><para>
                  <command>auto_exclude</command> : The libm exclusion is automatically detected thanks pattern detection. The library detected  are libm, vgpreload_verrou, interlibmath, libquadmath and libgcc_s. If you need to perturb libgcc_s, we will need to use libgcc_s.
                </para></listitem>
                <listitem><para>
                  <command>manual_exclude</command> : The automatic detection is ignored and the user has to define manually the exclusion thanks <command>--exclude</command> option. This option is useful if the pattern detection detect object you need to perturb.
                </para></listitem>
		<listitem><para>
                  <command>instrumented</command> : the interposition library Interlibmath is loaded (The complex libm function are not yet instrumented). This option is valid only with verrou backend. This option imply implicitly the libm exclusion.
                </para></listitem>
              </itemizedlist>

	      <para>
		The option <command>instrumented</command> is quite new. In a near future, the default will switch from <command>auto_exclude</command> to <command>instrumented</command>
	      </para>
            </listitem>
	  </varlistentry>
	  <varlistentry id="vr-opt.libm-noinst-rounding-mode" xreflabel="--libm-noinst-rounding-mode=">
            <term><option><![CDATA[--libm-noinst-rounding-mode==<native|nearest> [default=native]]]></option></term>
	      <listitem>
	      <para>
		Select the behavior of libm (when <option>--libm=instrumented</option> is activated) when libm function are not instrumented (thanks <option>--exclude</option> or <option>--source</option>) between <command>native</command> and <command>nearest</command>.
	      </para>

	      <para>This option can be activated with the env variable <command>VERROU_LIBM_NOINST_ROUNDING_MODE</command>.</para>
	      </listitem>
	  </varlistentry>
			  <varlistentry id="vr-opt.mca-mode" xreflabel="--mca-mode">
            <term><option><![CDATA[--mca-mode=<mca|rr|pb|ieee> [default=mca]]]></option></term>
            <listitem>
              <para>
                Emulate the given MCA mode for operations instrumented with the mcaquad backend. Supported mca modes are:
              </para>
              <itemizedlist>
                <listitem><para>
                  <command>mca : </command> <computeroutput>full mca</computeroutput> (default)
                </para></listitem>
                <listitem><para>
                  <command>rr : </command> <computeroutput> random rounding</computeroutput>
                </para></listitem>
		<listitem><para>
                  <command>pb : </command> <computeroutput> precision bounding</computeroutput>
                </para></listitem>
		<listitem><para>
                  <command>ieee : </command> <computeroutput> ieee (rounding to nearest)</computeroutput>
                </para></listitem>
              </itemizedlist>

	      <para> The mcaquad backend implementation come from Verificarlo : <ulink url="https://github.com/verificarlo/verificarlo"> More information on Verificalo github </ulink>
	      </para>
	      <para>This option can be activated with the env variable <command>VERROU_MCA_MODE</command>.</para>
            </listitem>
          </varlistentry>
	  <varlistentry id="vr-opt.mca-precision-double" xreflabel="--mca-precision-double">
            <term><option><![CDATA[--mca-precision-double= [default=53]]]></option></term>
            <listitem>
              <para>
                Configure the magnitude of inexact function used by mcaquad backend for double operation.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_MCA_PRECISION_DOUBLE</command>.</para>

            </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.mca-precision-float" xreflabel="--mca-precision-float">
            <term><option><![CDATA[--mca-precision-float= [default=24]]]></option></term>
            <listitem>
              <para>
                Configure the magnitude of inexact function used by mcaquad backend for float operation.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_MCA_PRECISION_FLOAT</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.seed" xreflabel="--vr-seed">
            <term><option><![CDATA[--vr-seed=RNG_SEED [default=automatically generated]]]></option></term>
            <listitem>
              <para>If present, this option allows setting the seed of the
              pseudo-Random Number Generator used for the
		<command>random</command> or
		<command>average </command> <link linkend="vr-manual.feat.rounding-mode">rounding modes</link>.
		The same option can also be used to set the seed of the hash function used for the [p]random_[com]det and average_[com]det
		rounding mode.
		This helps reproducing the behavior of a program under Verrou.
              </para>
              <para>If this option is omitted, the pRNG is seeded with a value
              based on the current time and process id, so that it should change
              at each execution.</para>
	      <para>This option can be activated with the env variable <command>VERROU_SEED</command>.</para>
            </listitem>
          </varlistentry>


	  <varlistentry id="vr-manual.feat.updatepfunc" xreflabel="--prandom-update">
            <term><option><![CDATA[--prandom-update=func [default=none]]]></option></term>
            <listitem>
              <para>If present, this option the p-value of the prandom[|det|comdet] rounding mode is
		updated (with an uniform random selection between 0 and 1) at the beginning of each function call.
		Be careful the option is highly sensitive
		to the program compilation option. If each the update is inserted between each floating point
		operations the  <link linkend="vr-manual.feat.rounding-mode">prandom and random modes</link> are equivalent.
		</para>
		<para>This option can be activated with the env variable <command>VERROU_PRANDOM_UPDATE</command>.</para>
              </listitem>
          </varlistentry>

	    <varlistentry id="vr-manual.feat.updatepvalue" xreflabel="--prandom-pvalue">
            <term><option><![CDATA[--prandom-pvalue=P ]]></option></term>
            <listitem>
              <para>If present, this option the p-value of the prandom[|det|comdet] rounding mode is
		set to P instead of the random number between 0 and 1.
		If P is equal to 0., prandom and upward are equivalent.
		If P is equal to 1., prandom and downward are equivalent.
		If P is equal to .5, prandom and random are equivalent.
	      </para>
		<para>This option can be activated with the env variable <command>VERROU_PRANDOM_PVALUE</command>.</para>
              </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.instr" xreflabel="--vr-instr-">
            <term><option><![CDATA[--vr-instr=<add|sub|mul|div|mAdd|mSub|sqrt|conv> [default=all]]]></option></term>
            <listitem>
              <para>Toggle instrumentation of floating-point additions,
                subtractions, multiplications, divisions, fused multiply
                additions, fused multiply subtractions, square root, conversions (only double to float cast) respectively.
		This option can be set multiple times (or use "," to separate arguments) to instrument multiple types of
                operations.</para>
              <para>If this option is not provided, all supported operations
		types are instrumented.</para>
	      <para>This option can be activated with the env variable <command>VERROU_INSTR</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.instr-scalar" xreflabel="--vr-instr-scalar-">
            <term><option><![CDATA[--vr-instr-scalar=<yes|no> [default=no]]]></option></term>
            <listitem><para>
                Toggle instrumentation of x387 scalar instructions.
		On arm64 architecture, this option is set by default to yes, as scalar instructions respect the IEEE standard.
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.instr-llo" xreflabel="--vr-instr-llo-">
            <term><option><![CDATA[--vr-instr-llo=<yes|no> [default=yes]]]></option></term>
            <listitem><para>
                Toggle instrumentation of llo scalar instructions (cast and all fma instructions are considered as llo).
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.instr-vec" xreflabel="--vr-instr-vec-">
            <term><option><![CDATA[--vr-instr-vec<2,4,8>=<yes|no> [default=yes]]]></option></term>
            <listitem><para>
                Toggle instrumentation of vectorized instructions (number corresponds to the pack size)
            </para></listitem>
          </varlistentry>
	  <varlistentry id="vr-opt.instr-unk" xreflabel="--vr-instr-unk">
            <term><option><![CDATA[--vr-instr-unk=<yes|no> [default=yes]]]></option></term>
            <listitem><para>
                Toggle instrumentation of instructions with unknown vectorized status (fma is unvectorized in valgrind IR).
            </para></listitem>
          </varlistentry>

	    <varlistentry id="vr-opt.instr-TYPE" xreflabel="--vr-instr-[flt|dbl]-">
            <term><option><![CDATA[--vr-instr-[flt|dbl]=<yes|no> [default=yes]]]></option></term>
            <listitem><para>
                Toggle instrumentation of float (or double) instructions.
              </para>
	    </listitem>
           </varlistentry>

	  </variablelist>
      </section>

      <section>
        <title>Restriction of instrumentation scope</title>
        <variablelist id="vr.opts.scope.list">

          <varlistentry id="vr-opt.instr-atstart" xreflabel="--instr-atstart">
            <term><option><![CDATA[--instr-atstart=<yes|no> [default=yes]]]></option></term>
              <listitem><para>Toggle <link linkend="vr-manual.feat.instr">hard instrumentation
                    state</link> on or off at program start. Useful in combination
                  with <link linkend="vr-cr.start-instrumentation">client
                    requests</link>.
		</para>
		<para>This option can be activated with the env variable <command>VERROU_INSTR_ATSTART</command>.</para>
	      </listitem>
            </varlistentry>

	    <varlistentry id="vr-opt.instr-atstart-soft" xreflabel="--instr-atstart-soft">
              <term><option><![CDATA[--instr-atstart-soft=<yes|no> [default=yes]]]></option></term>
		<listitem><para>Toggle <link linkend="vr-manual.feat.instr">soft instrumentation
                      state</link> on or off at program start. Useful in combination
                    with <link linkend="vr-cr.start-instrumentation">client
                      requests</link>.
		  </para>
		  <para>This option can be activated with the env variable <command>VERROU_INSTR_ATSTART_SOFT</command>.</para>
		</listitem>
              </varlistentry>

          <varlistentry id="vr-opt.exclude" xreflabel="--exclude">
            <term><option><![CDATA[--exclude=FILE]]></option></term>
            <listitem><para>Symbols listed
                in <computeroutput>FILE</computeroutput> will be
                left <link linkend="vr-manual.feat.exclude">uninstrumented</link>.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_EXCLUDE</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.gen-exclude" xreflabel="--gen-exclude">
            <term><option><![CDATA[--gen-exclude=FILE]]></option></term>
            <listitem>
              <para>Generate in <computeroutput>FILE</computeroutput> a list of
                all symbols (which contain perturbed floating point instruction)
		encountered during program execution. This is useful
                to build an <link linkend="vr-manual.feat.exclude">exclusion
                list</link>.</para>
              <para>In combination
              with <xref linkend="vr-opt.exclude"/>, only list
              symbols which were not already present in the provided exclusion
              list.</para>
              <para>
                WARNING: in order to generate a correct list, the whole binary
                (including symbols listed in the list provided
                using <xref linkend="vr-opt.exclude"/>) must be
                instrumented. When using
                both <xref linkend="vr-opt.gen-exclude"/>
                and <xref linkend="vr-opt.exclude"/>, it is
                advised to avoid perturbing rounding-modes
                using <xref linkend="vr-opt.rounding-mode"/><![CDATA[=nearest]]>.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_GEN_EXCLUDE</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.source" xreflabel="--source">
            <term><option><![CDATA[--source=FILE]]></option></term>
            <listitem><para>When this option is present, only instructions
                coming from <link linkend="vr-manual.feat.source">source code
                lines</link> listed in <computeroutput>FILE</computeroutput>
                are instrumented.</para>
	      <para>This option can be activated with the env variable <command>VERROU_SOURCE</command>.</para>
	    </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.warn-unknown-source" xreflabel="--warn-unknown-source">
            <term><option><![CDATA[--warn-unknown-source=FILE]]></option></term>
            <listitem><para> This option requires the use of <command>--source</command> option. When used, verrou generates warning for each line of code (which execute floating point operation) neither present in the FILE defined by <command>--source</command> option  nor in the FILE provided by <command>--warn-unknown-source</command> option.
	      </para>
	      <para>This option can be activated with the env variable <command>VERROU_WARN_UNKNOWN_SOURCE</command>.</para>
	    </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.gen-source" xreflabel="--gen-source">
            <term><option><![CDATA[--gen-source=FILE]]></option></term>
            <listitem>
              <para>Generate in <computeroutput>FILE</computeroutput> the list
                of all <link linkend="vr-manual.feat.source">source code
                  lines</link> (which contain perturbed floating point instruction)
		encountered during program execution.</para>
              <para>In combination with
                <xref linkend="vr-opt.source"/>, only list
                source code lines which were not already present in the provided
                list.</para>
	      <para>This option can be activated with the env variable <command>VERROU_GEN_SOURCE</command>.</para>
            </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.exclude-backtrace" xreflabel="--exclude-backtrace">
            <term><option><![CDATA[--exclude-backtrace=FILE]]></option></term>
            <listitem><para>Backtrace listed
                in <computeroutput>FILE</computeroutput> will be
                left uninstrumented. In practice <computeroutput>FILE</computeroutput> is a subset of the file <computeroutput>backInfo-<replaceable>PID</replaceable></computeroutput> generated by the <option>--gen-backtrace</option> option.
		To keep addresses compatible between  <option>--exclude-backtrace</option> and  <option>--gen-backtrace</option> it is mandatory to disable ASLR (automatically done by <command>verrou_dd_back</command>).
              </para>


	      <para>
		This option is used by <command>verrou_dd_back</command>. Manual use is not expected but possible.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_EXCLUDE_BACKTRACE</command>.</para>
            </listitem>
          </varlistentry>

          <varlistentry id="vr-opt.gen-backtrace" xreflabel="--gen-backtrace">
            <term><option><![CDATA[--gen-backtrace=REP]]></option></term>
            <listitem>
              <para>Generate two files in <computeroutput>REP</computeroutput>:

		<itemizedlist>

		<listitem><para>
		  <computeroutput>backInfo-<replaceable>PID</replaceable></computeroutput> contains the list
		  of backtrace (One line per backtrace). The format is <computeroutput>STACKSIZE: address list</computeroutput>. The address separator is <computeroutput>,</computeroutput>.
		</para></listitem>

		<listitem><para>
		  <computeroutput>backAddrInfo-<replaceable>PID</replaceable></computeroutput> contains for each addresses of <computeroutput>BackInfo</computeroutput> file, the corresponding symbol and debug info (filename and linenum). The separator is the tabulation.
		</para></listitem>
		</itemizedlist>
	      </para>
              <para>
		This option is used by <command>verrou_dd_back</command>. Manual use is not expected but possible.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_GEN_BACKTRACE</command>.</para>
            </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.iomatch-clr" xreflabel="--IOmatch-clr">
            <term><option><![CDATA[--IOmatch-clr=IOMATCH_FILE]]></option></term>
            <listitem>
              <para> When this option is present the IOMatch script is read. This file
		defines the interaction between verrou and the stdout (<link linkend= "id.iomatch.format">See IOMatch format</link>). The main idea behind this format is to apply client request action when a line match a <computeroutput>bmatch:</computeroutput> (b for break) or <computeroutput>cmatch:</computeroutput> (c for continue) line. If a line match a bmatch the following match (b or c) are not tried. With a <computeroutput>cmatch:</computeroutput> the following match are tried.</para>

	      <para> The use of this option, may be sensitive to the bufferization of the program. In C++ std::endl flush the output, so we usually avoid the problem. In python, you can use PYTHONUNBUFFERED env variable. In C we proposed the library <computeroutput>verrouUnbuffered.so</computeroutput> (Loadable with LD_PRELOAD), to deactivate bufferization of stdout (For other file descriptors you have to flush manually, as it require more complex development). <command> verrou_dd_task</command> automatically use this two tricks.
	      </para>
	      <para>This option can be activated with the env variable <command>VERROU_IOMATCH_CLR</command>.</para>
	    </listitem>
          </varlistentry>

	  <varlistentry id="vr-opt.output-iomatch-rep" xreflabel="--output-IOmatch-rep">
            <term><option><![CDATA[--output-IOmatch-rep=REP]]></option></term>
            <listitem>
              <para> Specify the repository of IOmatch log file. By default the log file is
		<computeroutput>IOMATCH_FILE.log-PID</computeroutput>. With this option it is <computeroutput>REP/IOMatch.log-PID</computeroutput>. This option as also influence on the keys <computeroutput> dump-stdout:</computeroutput> and <computeroutput> dump-filtered-stdout:</computeroutput>of the <link linkend= "id.iomatch.format">IOMatch format</link>).
	      </para>

	      <para>This option can be activated with the env variable <command>VERROU_OUTPUT_IOMATCH_REP</command>.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section>
        <title>Coverage generation </title>
        <variablelist id="vr.opts.coverage.list">

          <varlistentry id="vr.opt.trace" xreflabel="--trace">
            <term><option><![CDATA[--trace=FILE]]></option></term>
            <listitem><para>
		Activate the <link linkend="vr-manual.localization.CovBB" >Basic Blocks Coverage</link> for the symbols specified in <computeroutput> FILE</computeroutput>.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_TRACE</command>.</para>
	    </listitem>
          </varlistentry>

	<varlistentry id="vr.opt.output-trace-rep" xreflabel="--output-trace-rep">
            <term><option><![CDATA[--output-trace-rep=REP]]></option></term>
            <listitem><para>
		Specify the <computeroutput>REP</computeroutput> directory for the trace output files.
              </para>
	      <para>This option can be activated with the env variable <command>VERROU_OUTPUT_TRACE_REP</command>.</para>
	    </listitem>
          </varlistentry>
	</variablelist>

      </section>

      <section>
        <title>Detection</title>
        <variablelist id="vr.opts.detection.list">

          <varlistentry id="vr.opt.check-nan" xreflabel="--check-nan">
            <term><option><![CDATA[--check-nan=<yes|no> [default=yes]]]></option></term>
              <listitem><para>
		  Activate NaN detection. NaN produces a valgrind error.
		  This functionality requires the verrou backend.
              </para></listitem>
            </varlistentry>

	    <varlistentry id="vr.opt.check-inf" xreflabel="--check-inf">
              <term><option><![CDATA[--check-inf=<yes|no> [default=yes]]]></option></term>
		<listitem><para>
		    Activate Inf detection. +/-Inf produces a valgrind error.
		    This functionality requires the verrou backend.
		</para></listitem>
              </varlistentry>

	  <varlistentry id="vr.opt.check-cancellation" xreflabel="--check-cancellation">
            <term><option><![CDATA[--check-cancellation=<yes|no> [default=no]]]></option></term>
            <listitem><para>
		Activate cancellation detection. Cancellation produces a valgrind error.
		This functionality is available for the verrou, mcaquad  and checkdenorm backends. The level
		of detected cancellations can be configured with <xref linkend="vr.opt.cc-threshold-float"/> and
		<xref linkend="vr.opt.cc-threshold-double"/>.
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr.opt.cc-gen-file" xreflabel="--cc-gen-file">
            <term><option><![CDATA[--cc-gen-file=<FILE>]]></option></term>
            <listitem><para>
		Generate in <computeroutput>FILE </computeroutput> with the source format for each code source line which produces at least one cancellation.
		This functionality is available for verrou, mcaquad and checkdenorm backends. The level
		of detected cancellations can be configured with <xref linkend="vr.opt.cc-threshold-float"/> and
		<xref linkend="vr.opt.cc-threshold-double"/>.
            </para></listitem>
          </varlistentry>


	  <varlistentry id="vr.opt.cc-threshold-float" xreflabel="--cc-threshold-float">
            <term><option><![CDATA[--cc-threshold-float=<integer> [default=24]]]></option></term>
            <listitem><para>
		Configure the cancellation detection threshold for float operations.
		Default value is still experimental and could have to change.
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr.opt.cc-threshold-double" xreflabel="--cc-threshold-double">
            <term><option><![CDATA[--cc-threshold-double=<integer> [default=40]]]></option></term>
            <listitem><para>
		Configure the cancellation  detection threshold for double operations.
		Default value is still experimental and could have to change.
            </para></listitem>
          </varlistentry>



	  <varlistentry id="vr.opt.check-denorm" xreflabel="--check-denorm">
            <term><option><![CDATA[--check-denorm=<yes|no> [default=no]]]></option></term>
            <listitem><para>
		Activate denormal number detection. Denormal number produced by floating point operation produces a valgrind error.
		This functionality is available for the checkdenorm backend.
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr.opt.cdi-gen-file" xreflabel="--cdi-gen-file">
            <term><option><![CDATA[--cdi-gen-file=<FILE>]]></option></term>
            <listitem><para>
		Generate in <computeroutput>FILE </computeroutput> with the source format for each code source line which reads (i for input) at least one denormal number.
		This functionality is available for checkdenorm backend.
            </para></listitem>
          </varlistentry>

	    <varlistentry id="vr.opt.cdo-gen-file" xreflabel="--cdo-gen-file">
            <term><option><![CDATA[--cdo-gen-file=<FILE>]]></option></term>
            <listitem><para>
		Generate in <computeroutput>FILE </computeroutput> with the source format for each code source line which produces (o for output) at least one denormal number.
		This functionality is available for checkdenorm backend.
            </para></listitem>
          </varlistentry>

	  <varlistentry id="vr.opt.float_max" xreflabel="--check-max-float">
            <term><option><![CDATA[--check-max-float=<yes|no> [default=no]]]></option></term>
            <listitem><para>
		Activate max float detection. This functionality is compatible only with verrou backend.
            </para></listitem>
          </varlistentry>

        </variablelist>
      </section>

    </section>
    <section id="vr-manual.client-requests" xreflabel="Verrou specific client requests">
      <title>Client requests</title>

      <para>Verrou provides the
        following <link linkend="manual-core-adv.clientreq">client
        requests</link> in the <filename>valgrind/verrou.h</filename>
        header.
      </para>

      <variablelist>

        <varlistentry id="vr-cr.display-counters"
                      xreflabel="VERROU_DISPLAY_COUNTERS">
          <term><computeroutput>VERROU_DISPLAY_COUNTERS</computeroutput></term>
          <listitem><para>Display the
              current <link linkend="vr-manual.feat.count">instructions
              counters</link>.</para></listitem>
        </varlistentry>

        <varlistentry id="vr-cr.start-instrumentation"
                      xreflabel="VERROU_START_INSTRUMENTATION">
          <term><computeroutput>VERROU_START_INSTRUMENTATION</computeroutput></term>
          <listitem><para>Start
              Verrou <link linkend="vr-manual.feat.instr">hard instrumentation</link>
              (including rounding mode switching) if not already
              enabled.</para></listitem>
        </varlistentry>

        <varlistentry id="vr-cr.stop-instrumentation"
                      xreflabel="VERROU_STOP_INSTRUMENTATION">
          <term><computeroutput>VERROU_STOP_INSTRUMENTATION</computeroutput></term>
          <listitem><para>Stop
              Verrou <link linkend="vr-manual.feat.instr">hard instrumentation</link>
              (don't switch rounding modes) if not already disabled.</para></listitem>
        </varlistentry>

        <varlistentry id="vr-cr.start-soft-instrumentation"
                      xreflabel="VERROU_START_SOFT_INSTRUMENTATION">
          <term><computeroutput>VERROU_START_SOFT_INSTRUMENTATION</computeroutput></term>
          <listitem><para>Start full
              Verrou <link linkend="vr-manual.feat.instr">soft instrumentation</link>
              (including rounding mode switching) if not already
              enabled.</para></listitem>
        </varlistentry>

        <varlistentry id="vr-cr.stop-soft-instrumentation"
                      xreflabel="VERROU_STOP_SOFT_INSTRUMENTATION">
          <term><computeroutput>VERROU_STOP_SOFT_INSTRUMENTATION</computeroutput></term>
          <listitem><para>Stop full
              Verrou <link linkend="vr-manual.feat.instr">soft instrumentation</link>
              (don't switch rounding modes) if not already disabled.</para></listitem>
        </varlistentry>

        <varlistentry id="vr-cr.start-deterministic"
                      xreflabel="VERROU_START_DETERMINISTIC(LEVEL)">
          <term><computeroutput>VERROU_START_DETERMINISTIC(LEVEL)</computeroutput></term>
          <listitem><para>Start
              a <link linkend="vr-manual.feat.deterministic">deterministic
              section</link>, i.e. one in which floating point operations are
              perturbed, but in a deterministic way.</para></listitem>
        </varlistentry>

        <varlistentry id="vr-cr.stop-deterministic"
                      xreflabel="VERROU_STOP_DETERMINISTIC(LEVEL)">
          <term><computeroutput>VERROU_STOP_DETERMINISTIC(LEVEL)</computeroutput></term>
          <listitem><para>Stop
              a <link linkend="vr-manual.feat.deterministic">deterministic
              section</link>, i.e. resume rounding mode switching in a
              (pseudo-)random way.</para></listitem>
        </varlistentry>


	<varlistentry id="vr-cr.dump-cover"
                      xreflabel="VERROU_DUMP_COVER">
          <term><computeroutput>VERROU_DUMP_COVER</computeroutput></term>
          <listitem><para> If <computeroutput>--trace</computeroutput> option is activated, the client request generates a partial cover and return the index of the cover.</para></listitem>
        </varlistentry>


	<varlistentry id="vr-manual.feat.clrupdatep"
                      xreflabel="VERROU_PRANDOM_UPDATE">
          <term><computeroutput>VERROU_PRANDOM_UPDATE</computeroutput></term>
          <listitem><para> The p-value of prandom[|_det|_comdet] rounding mode is set to a new random value between 0 and 1.</para></listitem>
        </varlistentry>

	<varlistentry id="vr-manual.feat.clrupdatepvalue"
                      xreflabel="VERROU_PRANDOM_UPDATE_VALUE">
          <term><computeroutput>VERROU_PRANDOM_UPDATE_VALUE(floatStr)</computeroutput></term>
          <listitem><para>  The p-value of prandom[|_det|_comdet] rounding mode is set to <computeroutput>floatStr</computeroutput>.</para></listitem>
        </varlistentry>
	<varlistentry id="vr-manual.feat.printDenormCounter"
                      xreflabel="VERROU_PRINT_DENORM_COUNTER">
          <term><computeroutput>VERROU_PRINT_DENORM_COUNTER</computeroutput></term>
          <listitem><para>Print the counter of checkdenorm backend.</para></listitem>
	</varlistentry>
	  <varlistentry id="vr-manual.feat.resetDenormCounter"
                      xreflabel="VERROU_PRINT_DENORM_COUNTER">
          <term><computeroutput>VERROU_RESET_DENORM_COUNTER</computeroutput></term>
          <listitem><para>Reset counters of checkDenorm backend.</para></listitem>
	</varlistentry>

	  <varlistentry id="vr-manual.feat.set_seed"
                      xreflabel="VERROU_SET_SEED">
          <term><computeroutput>VERROU_SET_ROUNDING_MODE</computeroutput></term>
          <listitem><para>Set the seed.</para></listitem>
	</varlistentry>

	  <varlistentry id="vr-manual.feat.set_rounding_mode"
                      xreflabel="VERROU_SET_ROUNDING_MODE">
          <term><computeroutput>VERROU_SET_ROUNDING_MODE</computeroutput></term>
          <listitem><para>Set the rounding mode (imply flush of instrumentation cache).</para></listitem>
	</varlistentry>

      </variablelist>
    </section>

    <section id="id.iomatch.format" xreflabel="IOMatch format">
      <title>IOMatch script</title>
      <para>
	The IOMatch script is activated thanks the option <xref linkend="vr-opt.iomatch-clr"/><option>=IOMATCH_FILE</option>.
	The comment symbol is <computeroutput>#</computeroutput>.
      </para>
      <para>
      The file can contain the configuration keys :
      <variablelist>
	<varlistentry>
	  <term><computeroutput>verbose: LEVEL</computeroutput></term>
	  <listitem><para> Configure the verbosity level (default 1)
	  </para></listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>ignore-empty-line:</computeroutput></term>
	  <listitem><para>
	    If this key is present, the empty lines are ignored.
	  </para></listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>filter_line_exec: CMD</computeroutput></term>
	  <listitem><para>
	    Activate the line replacement with CMD.
	    </para>
	    <para>
	      The first argument of <computeroutput>CMD</computeroutput> has to be a path absolute (or relative if there is no CWD change). This option is not (yet) able to read the <computeroutput>$PATH</computeroutput> env variable. All the space are used to separate command arguments. To prevent this behaviour, the only way is to escape the space by a backslash.</para>
	  </listitem>

	</varlistentry>

	<varlistentry>
	  <term><computeroutput>dump-stdout: [FILENAME]</computeroutput></term>
	  <listitem><para>
	    Dump the stdout file. If FILENAME is not set the default name is <computeroutput>IOMATCH_FILE.stdout-PID</computeroutput> or <computeroutput>IOMATCH_OUTPUT_REP/iomatch.stdout-PID</computeroutput> (if option <option>--output-IOmatch-rep=IOMATCH_OUTPUT_REP</option> is used). Remark: <computeroutput>FILENAME</computeroutput> absolute path and <option>--output-IOmatch-rep=</option> are incompatible.
	    </para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>dump-filtered-stdout: [FILENAME]</computeroutput></term>
	  <listitem><para>
	    Dump the stdout file after application of <computeroutput>filter_line_exec CMD</computeroutput> to each line.
	     If FILENAME is not set the default name is <computeroutput>IOMATCH_FILE.filtered.stdout-PID</computeroutput> (or <computeroutput>IOMATCH_OUTPUT_REP/iomatch.filtered.stdout-PID</computeroutput> if option <option>--output-IOmatch-rep=IOMATCH_OUTPUT_REP</option> is used). Remark: <computeroutput>FILENAME</computeroutput> absolute path and <option>--output-IOmatch-rep=</option> are incompatible.
	    </para></listitem>
	</varlistentry>
      </variablelist>

      </para>
      <para>
	We can also set up action for each section.
	<variablelist>
	<varlistentry>
	  <term><computeroutput>default: ACTION</computeroutput></term>
	  <listitem><para>
	    Add ACTION to the default section.
	  </para></listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>init: ACTION</computeroutput></term>
	  <listitem><para>
	    Add ACTION to the init section. This action will be executed during the verrou initialization.
	  </para></listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>post-init: ACTION</computeroutput></term>
	  <listitem><para>
	    Add ACTION to the post-init section. This action will be executed when the first stdout line appears.
	  </para></listitem>
	</varlistentry>
	</variablelist>
      </para>
      <para>
	Lastly match section with associated actions can be defined:
	<variablelist>
	<varlistentry>
	  <term><computeroutput>bmatch: PATTERN</computeroutput></term>
	  <listitem><para>
	    Setup a break match section. <computeroutput>PATTERN</computeroutput> is a wildcard expression with * and ?. The first space after :
	    is a part of the format. Every space after this one is meaningful. The order of match section is important.
	    If the first match is *. All following match section are ignored. The action associated to the section are
	    defined in the following lines by <computeroutput>apply:</computeroutput> and <computeroutput>post-apply:</computeroutput>.
	    A break match (in contrast to continue match) mean that after a match the following match (continue or break) are ignored.
	  </para></listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>cmatch: PATTERN</computeroutput></term>
	  <listitem><para>
	    Setup a  continue match section. <computeroutput>PATTERN</computeroutput> is a wildcard expression with * and ?.
	    In contrast to break match, if a line match the following match are tried. It is not possible to define <computeroutput>post-apply</computeroutput> action with <computeroutput>cmatch:</computeroutput>.
	  </para></listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>apply: ACTION</computeroutput></term>
	  <listitem><para>
	    Add the ACTION to current <computeroutput>match</computeroutput> section. This action will be applied to the beginning of the match section.
	    If no action is set for a match section, the default group of action will be executed. To avoid the default action, you can use a
	    <computeroutput>nop</computeroutput> action.
	  </para></listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>post-apply: ACTION</computeroutput></term>
	  <listitem><para>
	    Add the ACTION to current <computeroutput>match</computeroutput> section. This action will be applied to the end of the match section.
	    If no post-action is defined, nothing is done (ie. no <computeroutput>default</computeroutput> action).
	  </para></listitem>
	</varlistentry>
      </variablelist>
      </para>

      <para>
The different possible actions are :
      <variablelist>
	<varlistentry>
	  <term><computeroutput>start</computeroutput></term>
	  <listitem> <para>Start instrumentation. </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>stop</computeroutput></term>
	  <listitem><para>
	    Stop instrumentation.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>start_soft</computeroutput></term>
	  <listitem><para> Start soft instrumentation.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>stop_soft</computeroutput></term>
	  <listitem><para>
	    Stop soft instrumentation.
	  </para></listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>nop</computeroutput></term>
	  <listitem><para>
	    do nothing (useful to avoid default action)
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>display_counter</computeroutput></term>
	  <listitem><para>
	    display counters
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>nb_instr</computeroutput></term>
	  <listitem><para>
	    Display the number of instrumented floating point operation in the log file.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>reset_counter</computeroutput></term>
	  <listitem><para>
	    Set all floating point counters to zero.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>dump_cover</computeroutput></term>
	  <listitem><para>
	    Apply <computeroutput>VERROU_DUMP_COVER</computeroutput> client request.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>print_denorm_counter</computeroutput></term>
	  <listitem><para>
	    Apply <computeroutput>VERROU_PRINT_DENORM_COUNTER</computeroutput> client request.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>reset_denorm_counter</computeroutput></term>
	  <listitem><para>
	    Apply <computeroutput>VERROU_RESET_DENORM_COUNTER</computeroutput> client request.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>backtrace</computeroutput></term>
	  <listitem><para>
	    Print backtrace.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>panic</computeroutput></term>
	  <listitem><para>
	    Stop program with panic.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><computeroutput>exit</computeroutput></term>
	  <listitem><para>
	    Stop program with exit.
	  </para></listitem>
	</varlistentry>

	<varlistentry>
	  <term><computeroutput>default,init,post-init</computeroutput></term>
	  <listitem><para>
	    Apply the same group of actions defined for the section <computeroutput>default</computeroutput>, <computeroutput>init</computeroutput> and <computeroutput>post-init</computeroutput>.
	  </para></listitem>
	</varlistentry>

      </variablelist>
      </para>
    </section>

    <section>
      <title>Monitor commands</title>

      <para>
      See <xref linkend="manual-core-adv.gdbserver"/> to get more information
      about the Valgrind gdbserver and monitor commands. Below is a list of
      specific monitor commands provided by Verrou:
      </para>

      <variablelist>
        <varlistentry id="vr.monitor_count" xreflabel="count">
          <term><computeroutput>count</computeroutput></term>
          <listitem><para>Display the
              current <link linkend="vr-manual.feat.count">instructions
                counters</link>.
          </para></listitem>
        </varlistentry>
        <varlistentry id="vr.monitor_instrumentation" xreflabel="instrumentation">
          <term><computeroutput>instrumentation [on|off]</computeroutput></term>
          <listitem><para> Set the
              current <link linkend="vr-manual.feat.instr">instrumentation
              state</link> (or print it if
              no <computeroutput>on</computeroutput>
              / <computeroutput>off</computeroutput> parameter is given).
          </para></listitem>
        </varlistentry>
      </variablelist>
    </section>
	  </section>
	  <section>
	    <title>Frequently Asked Questions</title>
	    <qandaset>
	      <qandadiv id="faq.compilation">
		<title>Compilation</title>
		    <qandaentry id="faq.stoch.docbook">
		      <question>
			<para>
			  What's going wrong with the following error during documentation compilation :
			  <screen>
compilation error: file ../docs/lib/vg-html-common.xsl line 4 element import
xsl:import : unable to load http://docbook.sourceforge.net/release/xsl/current/html/docbook.xsl</screen>
			</para>
		      </question>
		      <answer>
			<para>
			You should install the package  <computeroutput>docbook-xsl</computeroutput>
			</para>
		      </answer>
		    </qandaentry>
		  </qandadiv>
	      <qandadiv id="faq.stoch">
		<title>Stochastic method</title>

		<qandaentry id="faq.stoch.sample">
		  <question id="q-stoch.sample">
		    <para>
		      How-many sample do I need for stochastic rounding?
		    </para>
		  </question>
		  <answer>
		    <para>
		      This <ulink url="https://hal.science/hal-01827319/document"> paper </ulink> describes in detail this question.
		      In practice I suggest working with Bernoulli estimators which do not require the centered normality assumption:

		      <itemizedlist>

			<listitem><simpara> The abs estimator is <inlineequation><mathphrase>max<subscript>i</subscript>(|X<subscript>i</subscript>-X<subscript>ieee</subscript>|)</mathphrase></inlineequation> .</simpara></listitem>
	  <listitem><simpara> The rel estimator is <inlineequation><mathphrase>max<subscript>i</subscript>(|X<subscript>i</subscript>-X<subscript>ieee</subscript>|)/|X<subscript>ieee</subscript>|</mathphrase></inlineequation> </simpara></listitem>
          <listitem><simpara> The binary rel estimator is <inlineequation><mathphrase>-log2(max<subscript>i</subscript>(|X<subscript>i</subscript>-X<subscript>ieee</subscript>|)/|X<subscript>ieee</subscript>|)</mathphrase></inlineequation></simpara></listitem>

		      </itemizedlist>
		    </para>
		    <para>
		      With these estimators, the number of samples can be computed before the runs from the expected probability and confidence level:

		      <table frame='all'>
			<title>Number of sample</title>
 <tgroup cols='10' align='center' colsep='1' rowsep='1'>
 <colspec colname='c1'/>
 <colspec colname='c2'/>
 <colspec colname='c3'/>
 <colspec colname='c4'/>
 <colspec colname='c5'/>
 <colspec colname='c6'/>
 <colspec colname='c7'/>
 <colspec colname='c8'/>
 <colspec colname='c9'/>
 <colspec colname='c10'/>

 <thead>

 <row>
   <entry align='center' morerows='1' valign='middle'>Confidence level 1-alpha</entry>
   <entry namest="c2" nameend="c10" align="center">Probability p</entry>
 </row>
 <row>
   <entry> 0.66 </entry><entry> 0.75 </entry><entry> 0.8 </entry><entry> 0.85 </entry><entry> 0.9 </entry><entry> 0.95 </entry><entry> 0.99 </entry><entry> 0.995 </entry><entry> 0.999</entry>
 </row>
 </thead>
 <tbody>

   <row><entry>0.75</entry><entry>4 </entry><entry> 5 </entry><entry> 7 </entry><entry> 9 </entry><entry> 14 </entry><entry> 28 </entry><entry> 138 </entry><entry> 277 </entry><entry> 1386</entry></row>

   <row><entry>0.8</entry><entry>4 </entry><entry> 6 </entry><entry> 8 </entry><entry> 10 </entry><entry> 16 </entry><entry> 32 </entry><entry> 161 </entry><entry> 322 </entry><entry> 1609</entry></row>

   <row><entry>0.85</entry><entry>5 </entry><entry> 7 </entry><entry> 9 </entry><entry> 12 </entry><entry> 19 </entry><entry> 37 </entry><entry> 189 </entry><entry> 379 </entry><entry> 1897</entry></row>

   <row><entry>0.9</entry><entry>6 </entry><entry> 9 </entry><entry> 11 </entry><entry> 15 </entry><entry> 22 </entry><entry> 45 </entry><entry> 230 </entry><entry> 460 </entry><entry> 2302</entry></row>

   <row><entry>0.95</entry><entry>8 </entry><entry> 11 </entry><entry> 14 </entry><entry> 19 </entry><entry> 29 </entry><entry> 59 </entry><entry> 299 </entry><entry> 598 </entry><entry> 2995</entry></row>

   <row><entry> 0.99</entry><entry>12 </entry><entry> 17 </entry><entry> 21 </entry><entry> 29 </entry><entry> 44 </entry><entry> 90 </entry><entry> 459 </entry><entry> 919 </entry><entry> 4603</entry></row>

   <row><entry>0.995</entry><entry>13 </entry><entry> 19 </entry><entry> 24 </entry><entry> 33 </entry><entry> 51 </entry><entry> 104 </entry><entry> 528 </entry><entry> 1058 </entry><entry> 5296</entry></row>

   <row><entry>0.999</entry><entry>17 </entry><entry> 25 </entry><entry> 31 </entry><entry> 43 </entry><entry> 66 </entry><entry> 135 </entry><entry> 688 </entry><entry> 1379 </entry><entry> 6905</entry></row>
 </tbody>
 </tgroup>
		      </table>
		    </para>
		    <para>
		      The confidence interval say us if it is useful to do more samples, but it say us nothing about the quality of stochastic modelization. You can remark, that the number of samples does not depend on the kind of rounding.
		    </para>
		  </answer>
		</qandaentry>

		<qandaentry id="faq.stoch.int">
		  <question id="q-stoch.int">
		    <para>
		      Why stochastic approach instead of interval arithmetic?
		    </para>
		  </question>
		  <answer>
		    <para>
		      Interval arithmetic is very attractive because it provide guarantee and you do not have to deal with confidence intervals.
		      But it has of several disadvantages:
		    </para>
		    <itemizedlist>

		  <listitem>
		    <para> The result interval is often very large. To solve this problem you can use multi-precision interval arithmetic.
		      It is too expensive for industrial use, but very handy for small functions to get a ground truth reference. I use it
		      to check tricky corrections of small functions at source level.
		    </para>
		  </listitem>
		  <listitem>
		    <para> Interval arithmetic is designed to provide reference results not to verify an existing code. In fact, interval arithmetic often
		      imply to modify the algorithm (ie a specific algorithm for newton iteration is needed).
		    </para>
		  </listitem>

		  <listitem>
		    <para>
		      Interval arithmetic is incompatible with binary instrumentation (at least to my knowledge). In fact to implement interval arithmetic we need a
		      shadow memory for floating-point data that works without any assumptions (with assumptions you will lose the main interest: guarantee).
		      I don't know a perfect shadow memory implementation. It is a very hard task, because the compiler can generate floating-point code in integer registers.
		      The best, but not perfect, floating point shadow memory for binary instrumentation is done (at least to my knowledge) by the impressive tool
		      <ulink url="https://github.com/SciCompKL/derivgrind"> derivgrind </ulink>
		    </para>
		  </listitem>

		    </itemizedlist>
		    <para>
		      Interval arithmetic and stochastic arithmetic are complementary. Indeed since verrou relies on stochastic arithmetic modelling, we need
		      ground truth references for validation. This reference can be provided by multi-precision interval arithmetic.
		    </para>

		  </answer>
		</qandaentry>

	      </qandadiv>
	      <qandadiv id="faq.instr">
		<title>Instrumentation</title>

		<qandaentry id="faq.instr.noverrou">
		  <question id="q-instr.noverrou">

		    <para> What's going wrong when I get the following error?
<screen>valgrind: failed to start tool 'verrou' for platform 'amd64-linux': No such file or directory</screen></para>
		  </question>
		  <answer id="a-instr.noverrou">
		    <para> Two possible explanations: </para>
		    <itemizedlist>
		      <listitem>
			<para>
			  You may have forgotten to load the verrou environment :
		      <screen>source INSTALL_PREFIX/env.sh</screen>
		      You can easily check this with <option>which</option> command. You will get this error if another installation without verrou is found.
			</para>
		      </listitem>
		      <listitem>
			<para>
			  Maybe you forgot to apply the verrou patches when compiling verrou:
			  <screen>cat verrou/valgrind.*diff | patch -p1</screen>
			</para>
		      </listitem>
		    </itemizedlist>
		  </answer>
		</qandaentry>


		<qandaentry id="faq.instr.wrapper">
		  <question id="q-instr.wrapper">
		    <para> verrou does not detect floating-point operation.</para>
		  </question>
		  <answer id="a-instr.wrapper">
		    <para> There are two classic explanations for this: </para>
		    <itemizedlist>
		      <listitem>
			<para>
			  Your program does not perform floating-point operations :)
			</para>
		      </listitem>
		      <listitem>
			<para>
			  You can instrument a wrapper such as a bash script instead of your program.
			</para>
		      </listitem>
		      </itemizedlist>

		      <para> There are three solutions </para>
		      <itemizedlist>
		      <listitem>
			<para>
			  Modify the wrapper to instrument the binary of interest
			</para>
		      </listitem>
		      <listitem>
			<para>
			  Use a <option>--prefix=</option>  or <option>--tool=</option> option provided by the wrapper.
			</para>
		      </listitem>
		      <listitem>
			<para>
			  Use a <option>--trace-children=yes</option> option provided by valgrind. To reduce the number of instrumented processes, you should consider using <option>--trace-children-skip=</option> and <option>--trace-children-skip-by-arg=</option> options.

			</para>
		      </listitem>

		      </itemizedlist>
		  </answer>
		</qandaentry>

		<qandaentry id="faq.instr.out">
		  <question id="q-instr.out">

		    <para> With verrou, I do not see any perturbation.</para>
		  </question>
		  <answer id="a-instr.out">
		    <para> There are two classic explanations: </para>
		    <itemizedlist>
		      <listitem>
			<para>
			  You are only instrumenting a wrapper (see specfic question).
			</para>
		      </listitem>
		      <listitem>
			<para>
			  The rounding of the output format is not perturbed by verrou. If the numerical noise is less than the output rounding, the noise can be hidden.
			</para>
		      </listitem>
		      </itemizedlist>

		      <para> If you need to change output format</para>
		      <itemizedlist>
		      <listitem>
			<para>
			  For C++ code: <programlisting><![CDATA[std::cout <<std::setprecision(17);]]></programlisting>

			  If your code does not use any formatting. You can use an LD_PRELOAD trick to force this command at the beginning of your program.
			  <programlisting><![CDATA[LD_PRELOAD=verrouExtendStdoutPrecision.so]]></programlisting>

			</para>
		      </listitem>
		      <listitem>
			<para>
			  For Fortran code:
 <programlisting><![CDATA[	  WRITE( ∗ , 42 ) MYFLOAT
42	  FORMAT( d25.17 )]]></programlisting>
			</para>
		      </listitem>
		      <listitem>
			<para>
			  Python works fine by default. You should be careful with output that is explicitly formatted with few digits.
			</para>
		      </listitem>

		      </itemizedlist>

		  </answer>
		</qandaentry>

		<qandaentry id="faq.inst.emul">
		  <question id="q-inst.emul">
		    <para>
		      My code use emulated floating point type (such as float128 or quad). What can I do?
		    </para>
		  </question>
		  <answer>
		    <para>
		      Nothing
		    </para>
		  </answer>
		</qandaentry>

		<qandaentry id="faq.inst.windows">
		  <question id="q-inst.windows">
		    <para>
		      My code runs under windows. What can I do?
		    </para>
		  </question>
		  <answer>
		    <para>
		      Port your code to GNU/Linux :)
		    </para>
		    <para>
		      Check the progress of the <ulink url="https://github.com/aneoconsulting/PENE">PENE</ulink> project.
		    </para>
		  </answer>
		</qandaentry>

		<qandaentry id="faq.inst.avx512">
		  <question id="q-inst.avx512">
		    <para>
		      My code uses AVX512. What can I do?
		    </para>
		  </question>
		  <answer>
		    <para>
		      Recompile your code with the <option>-mno-avx512f-</option> option.
		    </para>
		    <para>
		      Check the progress of the <ulink url="https://github.com/aneoconsulting/PENE">PENE</ulink> project.
		    </para>
		  </answer>
		</qandaentry>

		<qandaentry id="faq.inst.verbose">
		  <question id="q-inst.verbose">
		    <para>
		      Verrou is too verbose. What can I do?
		    </para>
		  </question>
		  <answer>
		    <para>
		      Verrou is quite verbose by default. There are two reasons for this:

		      <itemizedlist>
			<listitem>
			<para>
			  It is easy to instrument a wrapper and counters are the easiest way to detect this behavior.
			</para>
		      </listitem>
		      <listitem>
			<para>
			  The behavior of verrou can be changed using environment variables. The easiest way to detect typos, or forgotten environment variable settings is to read verrou's status.
			</para>
		      </listitem>
		      </itemizedlist>

		    </para>
		    <para>
		     However, if you want verrou to be less verbose you can use the <option>--quiet --count-op=no</option> options.
		    </para>
		  </answer>
		</qandaentry>

		<qandaentry id="faq.inst.native">
		  <question id="q-inst.native">
		    <para>
		      Verrou with nearest rounding-mode and the native execution (my program without valgrind) do not give the same result.  What can I do?
		    </para>
		  </question>
		  <answer>
		    <para>
		      There are several possible causes:
		    </para>
		    <para>
		      <itemizedlist>
			<listitem>
			<para>
			  Your native execution is not deterministic.
			</para>
		      </listitem>
			<listitem>
			  <para>
			    This is a valgrind emulation problem. If you use x87 opcodes, or fp flags (such as floating point trap or rounding mode setting) in your code, you may encounter this problem.
			    To check this, you can use <option> valgrind --tool=none  --show-emwarns=yes</option>. With  amd64 architecture, if you see Scal instructions with verrou, it means you have x87 opcode.
			  </para>
			</listitem>
			<listitem>
			<para>
			  Your code is doing introspection: your code can choose one algorithm or another depending on a computing time or memory consumption. In this can you should use an option to disable this introspection. If this is not possible, I have no solution for you.
			</para>
		      </listitem>
		      </itemizedlist>

		    </para>
		    <para>
		    </para>
		  </answer>
		</qandaentry>


		<qandaentry id="faq.inst.fmasqrt">
		  <question id="q-inst.fmasqrt">
		    <para>
		      There are two kinds (opcode or libm) of fma operation (resp. sqrt). What are the consequences for the user?
		    </para>
		  </question>
		  <answer>
		    <para>
		      The fma  (resp.) sqrt can be implemented in hardware or implemented in libm function.
		      For the user it as consequences :
		    </para>
		    <para>
		      <itemizedlist>
			<listitem>
			  <para>
			    The counters are not the same: MAdd,MSub,sqrt for hardware and fma,fmaf,sqrt,sqrtf for libm.
			  </para>
			</listitem>
			<listitem>
			  <para>
			    You can have a thinner control with hardware fma (line localization and <option>-vr-instr=mAdd,mSub</option>). With libm
			    you can select libm function only with <option>--exclude</option> or <option>--source=</option>: the limitation comes from
			    the lack of backtrace localization.
			  </para>
			</listitem>
			<listitem>
			  <para>
			  By default libm is not instrumented.
			  </para>
			</listitem>
			<listitem>
			  <para>
			    fma hardware and fma libm are compatible with stochastic-deterministic rounding mode ([average,random]_[[s[com]]det] and sr_[s]monotonic).
			  </para>
			  <para>
			    sqrt hardware and sqrt libm are considered as independent functions for stochastic-deterministic rounding mode.
			  </para>

			</listitem>
		      </itemizedlist>
		    </para>
		  </answer>
		</qandaentry>

		<qandaentry id="faq.inst.uncountop">
		  <question id="q-inst.uncountop">
		    <para>
		      We get <option>Uncounted operation</option> error message. What does it mean?
		    </para>
		  </question>
		  <answer>
		    <para>
		      This operation is neither counted nor perturbed and it should be.
		    </para>
		    <para>
		      Many of these operations come from the x87 instruction set and can be avoided by using the dynamic library libm.
		    </para>

		    <para>
		      If you really need to instrument this operation, you should contact the verrou developer. You will increase your chance of convincing me
		      if you are able to compute the error done by this operation without any dependencies.
		    </para>

		  </answer>
		</qandaentry>

	      </qandadiv>


	      <qandadiv id="faq.dd">
		<title>Delta-Debug</title>

	      <qandaentry>
		<question>
		  <para>
		    verrou_dd_sym or verrou_dd_line?
		  </para>
	      </question>

	      <answer>
		    <itemizedlist>
		      <listitem>
			<para>
			  If your code is compiled without the <option>-g</option> option, verrou_dd_sym is the best option.
			</para>
		      </listitem>
		      <listitem>
			<para>
			  If your code is compiled with the <option>-g</option> option, verrou_dd_line is usually the best option.
			</para>
		      </listitem>

		      <listitem>
			<para>
			  You can start with verrou_dd_sym and apply verrou_dd_line to the results of verrou_dd_sym.
			  If you only apply verrou_dd_line to a selection of the result this approach is interesting. If you apply verrou_dd_line
			  to every result, I suggest you apply verrou_dd_line directly.
			</para>
		      </listitem>
		      </itemizedlist>

	      </answer>
	      </qandaentry>


	      <qandaentry>
		<question>
		  <para>
		    delta-debug is too slow: what can I do?
		  </para>
	      </question>

	      <answer>
		    <itemizedlist>
		      <listitem>
			<para>
			  Reduce the test case. Sometimes it is useful to adjust the threshold tolerance to be able to reduce the test case
			</para>
		      </listitem>

		      <listitem>
			<para>
			Can you reproduce your problem with a deterministic rounding (upward, downward, toward_zero, away_zero, farthest)? If so, you can run delta-debug with only one sample (<option>--nruns=1</option>).
			</para>
			</listitem>

		      <listitem>
			<para>
			Are you able to reproduce your problem with a subset of instructions (see <option>--vr-instr=</option>, <option>--vr-instr-vec*=</option>,  <option>--vr-instr-flt=</option>, <option>--vr-instr-dbl</option>). If so, this will reduce the cost of instrumentation and the size of the search space.
			</para>
			</listitem>

		      <listitem>
			<para>
			Sometimes the individual runs (FAIL or SUCCESS) can be very long due to quasi infinite noisy iterations  or due to NaN computation.
			To solve this problem, you can reduce the maximum number of iterations or introduce early exit. This can be done with manual code modification, with <option>--exit-on-first-error=yes</option> (in conjunction of <option>--suppression</option> to filter errors), or with an IOmatch script.
			</para>
			</listitem>

		      <listitem>
			<para>
			  If your script RUN and CMP are reentrant you can use the <option>--num-threads=</option> option. On a cluster it is possible to integrate the distribution into the RUN script.
			</para>
		      </listitem>

		      <listitem>
			<para>
			  The <option>--rddmin-heuristics-*=</option> options are useful to speed-up the delta-debug, if you think
			  you will find the same unstable lines again.
			</para>
		      </listitem>

		      <listitem>
			<para>
			  The <option>--exclude=</option> option (not the environment variable VERROU_EXCLUDE) is helpful to reduce the search space.
			</para>
		      </listitem>

		      <listitem>
			<para>
			  Be patient, enjoy your weekend.
			</para>
		      </listitem>

		      <listitem>
			<para>
			  Be impatient, help improve the parallelism of delta-debug.
			</para>
		      </listitem>


		      </itemizedlist>

	      </answer>

	    </qandaentry>

	      <qandaentry>
		<question>
		  <para>
		    The cache (like <option>dd.line</option>) footprint is too high.
		  </para>
	      </question>

	      <answer>
		    <itemizedlist>
		      <listitem>
			<para>
			 In ddRun script, you should only store useful data.
			</para>
		      </listitem>
		      <listitem>
			<para>
			 You can compress data, in ddRun script. In ddCmp script you must be able to read compressed data.
			</para>
		      </listitem>

		      <listitem>
			<para>
			  You can also compress data (or even delete unnecessary data) in ddCmp, but it will be incompatible with the  <option>--cache=keep_run</option> option.
			</para>
		      </listitem>

		      <listitem>
			<para>
			  Become a verrou developer, to add a new verrou_dd functionality to clean the cache dynamically.
			</para>
		      </listitem>
		      </itemizedlist>

	      </answer>

	    </qandaentry>


	    <qandaentry>
	      <question>
		<para>
		  The cache is corrupted because all computations fail due to full disk error.
		</para>
	      </question>

	      <answer>

		<para>To avoid to rerun all the delta-debug process, you should follow these steps</para>
		    <itemizedlist>
		      <listitem>
			<para>
			  Identify the first computation that fails due to a full disk error.
			</para>
		      </listitem>
		      <listitem>
			<para>
			  Delete all later computations (md5/dd.run???).
			</para>
		      </listitem>

		      <listitem>
			<para>
			  Re-run the delta-debug with the <option>--cache=continue</option> option.
			</para>
		      </listitem>
		    </itemizedlist>
	      </answer>

	    </qandaentry>

	      </qandadiv>
	    </qandaset>

	  </section>
	  </chapter>
