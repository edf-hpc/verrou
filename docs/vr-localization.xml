<?xml version="1.0"?> <!-- -*- sgml -*- -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
          "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<section id="vr-manual.localization" xreflabel="Error localization">
  <title>Debugging and error localization</title>

  <para>
    We describe in this section techniques which can help determining the origin of numerical errors
    in the source code of the analyzed program.
  </para>

  <section id="vr-manual.localization.dd" xreflabel="Delta-Debugging">
    <title>Delta-debugging with the <command>verrou_dd_sym</command>, <command>verrou_dd_line</command>, <command>verrou_dd_back</command>, <command>verrou_dd_task</command> and <command>verrou_dd_stdout</command> commands</title>
    <para id="vr-manual.dd.principle" xreflabel="Delta-Debugging Principle">

      The first technique builds upon Verrou's <link linkend="vr-manual.feat.scope">Instrumentation scope</link> features in
      order to perform a search of functions (or source code lines / verrou task / stdout task) whose perturbation produces the
      most important errors in final results. The idea is the following:
      <itemizedlist>
        <listitem><simpara>First, a complete list of all symbols (or line / backtrace / task / stdout task) which contain perturbed
	floating point instructions is generated. It is expected that
        perturbing all functions in this list will produce inexact results. On the other hand,
        excluding all symbols from the scope of perturbations should produce unperturbed
        results. This list is called the search space.</simpara></listitem>
        <listitem><simpara>By splitting the search space in two parts, and perturbing each half
        separately, it is possible to determine whether each perturbed half produces inexact
        results.</simpara></listitem>
        <listitem><simpara>Going on like this and performing a bisection of the search space, the
        algorithm eventually finds a subset of functions whose only perturbation is enough to
            produce inexact results. This Trial and Error algorithm is called <emphasis>Delta-Debugging</emphasis>.
	 Each trial (which corresponds to a subset of the search space) is called a configuration. As the evaluation of error is based on a stochastic evaluation there are several runs per configuration.</simpara>
	</listitem>
      </itemizedlist>

      Depending on the search space there are four different commands:
      <itemizedlist>
	<listitem>
	  <simpara><command>verrou_dd_sym</command> uses the symbol search space and uses <link linkend="vr-manual.feat.exclude">Excluded Symbols</link> to select parts of the program which are instrumented or not.</simpara>
	</listitem>
	<listitem><simpara>
	<command>verrou_dd_line</command> uses the code line search space and uses <link linkend="vr-manual.feat.source"> Source instrumentation</link> to select parts of the program which are instrumented or not. The results of this command are more useful if the code is compiled with debug option (<command>-g</command>).
	</simpara></listitem>

	<listitem><simpara>
	    <command>verrou_dd_back</command> uses the backtrace search space and uses <link linkend="vr-manual.feat.backtrace"> backtrace instrumentation</link> to select which parts of the program are instrumented or not. The results of this command are more useful if the code is compiled with the debug option (<command>-g</command>). As the instrumentation is computationally expensive, this command should be used after an initial filtering provided by <command>verrou_dd_line</command> (See <link linkend="vr-manual.verrou_dd_chain"> How to chain delta-debug</link>). The search space is the backtrace of the beginning of each Basic Blocs with instrumented floating-point operations. A backtrace is a list of stack addresses. The maximum size of the list is 40, and when comparing between two stacks (to detect equality) the last two elements of the stack are ignored for internal reasons. The backtrace pretty printout with symbols and code lines are not one-to-one with the backtrace addresses. Line detection is less accurate than the lines used by the <option>--source</option> option (and therefore by <command>verrou_dd_line</command>). Therefore, when running a <command>verrou_dd_back</command> after a <command>verrou_dd_line</command> seemingly incoherent results may be seen if  basic_block contains multiple debug symbols. The pretty print ignores below main symbols and internal python symbols.
	</simpara></listitem>

	<listitem><simpara>
	  <command>verrou_dd_task</command> uses verrou task search space (<link linkend="vr-manual.verrou_task" > See how to perform instrumentation</link>). This search space enable temporal localization. The task instrumentation can be automatic with python code but is intrusive for compiled codes. <command>verrou_dd_task</command> has <link linkend="verrou_dd_task_stdout.specific.option" > one specific option</link>.
	</simpara></listitem>
	<listitem><simpara>
	  <command>verrou_dd_stdout</command> performs localization in terms of code section defined by the lines of the stdout. The search space is not directly the stdout lines because from one perturbed execution to an other the lines may differ. To bypass the problem the search space is a list of wildcard expression (With the default search space, the float are replace by * and address by ?).</simpara>
	  <simpara>
	    The user do not need to instrument the code but may need to modify the dataset to increase the verbosity. As the command works without code recompilation, it is possible to work from one result of an other <command>verrou_dd_*</command> commands, without rerunning the previous search.
	  </simpara>
	  <simpara>
	    The user has to pay attention to bufferization. <command>verrou_dd_stdout</command> automatically setup the PYTHONUNBUFFERED env variable and deactivate the c bufferization of stdout (not FILE*) but it not always sufficient.
	  </simpara>
	  <simpara>
	  As there are more corner cases, there are specific options to tackle it (cf.  Specific options of <link linkend="verrou_dd_task_stdout.specific.option" >verrou_dd_task/stdout</link> and <link linkend="verrou_dd_stdout.specific.option" >verrou_dd_stdout</link>)</simpara>

	  </listitem>
      </itemizedlist>
    </para>

    <simplesect>
      <title>Synopsis</title>

      <screen><cmdsynopsis id="vr-manual.verrou_dd_sym.synopsis">
        <command>verrou_dd_sym [options]</command>
        <arg choice="req"><replaceable>/path/to/run_script</replaceable></arg>
        <arg choice="req"><replaceable>/path/to/cmp_script</replaceable></arg>
      </cmdsynopsis></screen>

      <screen><cmdsynopsis id="vr-manual.verrou_dd_line.synopsis">
        <command>verrou_dd_line [options]</command>
        <arg choice="req"><replaceable>/path/to/run_script</replaceable></arg>
        <arg choice="req"><replaceable>/path/to/cmp_script</replaceable></arg>
      </cmdsynopsis></screen>

      <screen><cmdsynopsis id="vr-manual.verrou_dd_back.synopsis">
        <command>verrou_dd_back [options]</command>
        <arg choice="req"><replaceable>/path/to/run_script</replaceable></arg>
        <arg choice="req"><replaceable>/path/to/cmp_script</replaceable></arg>
      </cmdsynopsis></screen>

      <screen><cmdsynopsis id="vr-manual.verrou_dd_task.synopsis">
        <command>verrou_dd_task [options]</command>
        <arg choice="req"><replaceable>/path/to/run_script</replaceable></arg>
        <arg choice="req"><replaceable>/path/to/cmp_script</replaceable></arg>
      </cmdsynopsis></screen>

      <screen><cmdsynopsis id="vr-manual.verrou_dd_stdout.synopsis">
        <command>verrou_dd_stdout [options]</command>
        <arg choice="req"><replaceable>/path/to/run_script</replaceable></arg>
        <arg choice="req"><replaceable>/path/to/cmp_script</replaceable></arg>
      </cmdsynopsis></screen>

    </simplesect>
    <simplesect>
      <title>Description</title>

      <para id="vr-manual.verrou_dd.desc">
        Arguments passed to <command>verrou_dd_*</command> are scripts.
	These scripts will be called during the delta-debugging process to automate
        the tasks of running your program under Verrou, and verifying the results. The scripts will
        be called with the following arguments:

        <variablelist>
          <varlistentry>
            <term>
	      <cmdsynopsis>
              <command><replaceable>run_script</replaceable></command>
              <arg choice="req"><replaceable>dir</replaceable></arg>
	      </cmdsynopsis>
              </term>
            <listitem><para> Should run your program under Verrou, and put the results somewhere
            under the <replaceable>dir</replaceable> directory. A minimal example could look like
            the following:</para>
            <programlisting>
#!/bin/bash
DIR="$1"
valgrind --tool=verrou --rounding-mode=random <replaceable>program args</replaceable> &gt; ${DIR}/results.dat</programlisting>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
	      <cmdsynopsis>
              <command><replaceable>cmp_script</replaceable></command>
              <arg choice="req"><replaceable>ref_dir</replaceable></arg>
              <arg choice="req"><replaceable>run_dir</replaceable></arg>
	      </cmdsynopsis>
            </term>
            <listitem>
              <simpara>
                Should check whether program results in <replaceable>run_dir</replaceable> (as
                stored by a previous call to
                <command><replaceable>run_script</replaceable></command>) are "valid". The precise
                meaning of "valid" is left for the user to determine, depending on the program being
                analyzed. If a comparison to reference results is needed, directory
                <replaceable>ref_dir</replaceable> contains the results produced by an
                uninstrumented run of the
                program. <command><replaceable>cmp_script</replaceable></command> should return 0 if
                and only if the results are "valid".
              </simpara>
              <simpara>
                A minimal example could look like the following:
              </simpara>
              <programlisting>
#!/bin/bash
REF="$1"
RUN="$2"
diff ${REF}/results.dat ${RUN}/results.dat</programlisting>
              <simpara>
	      A classical python script looks like this :
	      </simpara>
              <programlisting>
<![CDATA[import sys
import os
def extractValue(rep):
    """This parse function has to be adapted to each case"""
    lines=(open(os.path.join(rep,"results.dat")).readlines())
    for line in lines:
        if line.startswith("res="):
            return float(line.partition("=")[2])
    return None
if __name__=="__main__":
    if len(sys.argv)==2:
        #this case is to be compatible with the extract script of verrou_plot_stat
        print(extractValue(sys.argv[1]))
    if len(sys.argv)==3:
        valueRef=extractValue(sys.argv[1])
        value=extractValue(sys.argv[2])

        relDiff=abs((value-valueRef)/valueRef)
	#the tolerance has to be adapted
        if relDiff < 1.e-6:
	    sys.exit(0)
        else:
            sys.exit(1)]]></programlisting>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </simplesect>

    <simplesect>
      <title>Options and environment variables</title>

      <para>
        The following options or environment variables affect the behavior of <command>verrou_dd_sym</command>,  <command>verrou_dd_line</command>,  <command>verrou_dd_task</command>  and  <command>verrou_dd_stdout</command>:
      </para>

      <variablelist id="vr-manual.verrou_dd.envvars">
        <varlistentry>
          <term>
            <computeroutput>--nruns</computeroutput> or <computeroutput>VERROU_DD_NRUNS</computeroutput>
          </term>
          <listitem>
            <para>An integer setting the required number successful runs needed to consider a
            configuration as stable. If this environment variable is not set, the default value is
            5.</para>
          </listitem>
        </varlistentry>


	<varlistentry>
          <term>
             <computeroutput>--num-threads</computeroutput> or <computeroutput>VERROU_DD_NUM_THREADS</computeroutput>
          </term>
          <listitem>
            <para> Allows to perform <computeroutput>VERROU_DD_NUM_THREADS</computeroutput> runs in parallel.
	     If this environment variable is not set, the parallelism is not activated.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--reference-rounding</computeroutput> or <computeroutput>VERROU_REFERENCE_ROUNDING</computeroutput> [default native].
	  </term>
	  <listitem>
	  <para>
	    Select the reference rounding mode between native and nearest. The nearest and native rounding mode are different only when
	    the verrou option <option>--libm=instrumented</option> is used.
	  </para>
          </listitem>
        </varlistentry>

	<varlistentry>
          <term>
             <computeroutput>--res-with-all-samples </computeroutput> or <computeroutput>VERROU_DD_RES_WITH_ALL_SAMPLES</computeroutput>
          </term>
          <listitem>
            <para> Disable the early exit for result directories. It is useful to compute estimator for all
	    <computeroutput>ddmin*</computeroutput> directories with the same number of samples and hence
	    to sort them.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--algo=</computeroutput> or <computeroutput>VERROU_DD_ALGO</computeroutput>
          </term>
          <listitem>
            <para>
	      Option to choose one of the two Delta-Debugging algorithms (<computeroutput>ddmax</computeroutput> and <computeroutput>rddmin</computeroutput>).
	    </para>
	    <para>
	      <computeroutput>rddmin</computeroutput>: return recursively the min-set of unstable
	      symbols.
	    </para>
	    <para>
	      <computeroutput>ddmax</computeroutput>: return the max-set of stable symbols (or lines).
	    </para>

	    <para>
	    If this environment variable is not set, the default value is set to <computeroutput>rddmin</computeroutput>.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--rddmin=</computeroutput> or <computeroutput>VERROU_DD_RDDMIN</computeroutput>
          </term>
          <listitem>
            <para>
	      Option to choose one of the variant of rddmin algorithms.
	    </para>
	    <para>
	      "", <computeroutput>strict</computeroutput>: rddmin algorithm with constant number of samples
	    </para>
	    <para>
	      <computeroutput>s</computeroutput>, <computeroutput>stoch</computeroutput>: rddmin algorithm with increasing number of samples (called srddmin)
	    </para>
	    <para>
	      <computeroutput>d</computeroutput>, <computeroutput>dicho</computeroutput>: srddmin algorithm pre-filtered by a dichotomy method (called drddmin)
	    </para>

	    <para>
	    The default value is set to <computeroutput>dicho</computeroutput>.
	    </para>
          </listitem>
        </varlistentry>


	<varlistentry>
          <term>
            <computeroutput>--rddmin-tab=</computeroutput> or <computeroutput>VERROU_DD_RDDMIN_TAB</computeroutput>
          </term>
          <listitem>
            <para>
	      Option to choose the evolution of the number of samples used by the srddmin algorithm.
	    </para>
	    <para>
	      <computeroutput>exp</computeroutput>: increases the number of samples from 1 to
	      <computeroutput>VERROU_DD_NRUNS</computeroutput> with exponential rate.
	    </para>
	    <para>
	      <computeroutput>all</computeroutput>: consecutively try all numbers of samples from 1
	      to <computeroutput>VERROU_DD_NRUNS</computeroutput>.
	    </para>
	    <para>
	      <computeroutput>single</computeroutput>: directly use the number of samples given by
	      <computeroutput>VERROU_DD_NRUNS</computeroutput>. srddmin is equivalent to rddmin in
              this case.
	    </para>

	    <para>
	    The default value is set to <computeroutput>exp</computeroutput>.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
          <term>
	    <computeroutput>--dicho-tab=</computeroutput> or <computeroutput>VERROU_DD_DICHO_TAB</computeroutput>
          </term>
          <listitem>
            <para>
	      Option to choose the evolution of the number of samples used by the
              binary search in the first part of the drddmin algorithm.
	    </para>
	    <para>
	      <computeroutput>exp</computeroutput>: increases the number of samples from 1 to
	      <computeroutput>VERROU_DD_NRUNS</computeroutput> with exponential rate.
	    </para>
	    <para>
	      <computeroutput>all</computeroutput>: consecutively try all numbers of samples from 1
	      to <computeroutput>VERROU_DD_NRUNS</computeroutput>.
	    </para>
	    <para>
	      <computeroutput>single</computeroutput>: use the number of samples given by
	      <computeroutput>VERROU_DD_NRUNS</computeroutput>.
	    </para>
	    <para>
	      <computeroutput>half</computeroutput>: use half the number of samples given by
	      <computeroutput>VERROU_DD_NRUNS</computeroutput>.
	    </para>
	    <para>
	      <replaceable>N</replaceable>: user-provided value (must be an integer 
	      between 1 and <computeroutput>VERROU_DD_NRUNS</computeroutput>).
	    </para>

	    <para>
	    The default value is set to <computeroutput>half</computeroutput>.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
	  <term>
            <computeroutput>--dicho-granularity=</computeroutput> or <computeroutput>VERROU_DD_DICHO_GRANULARITY</computeroutput>
          </term>
        <listitem>
            <para>
	      Option to choose the granularity of the splitFunction of the dichotomy algorithm (used by drddmin).
	    </para>
	    <para>
	    The default value is set to 2. Higher value may help parallelism.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
	  <term>
            <computeroutput>--quiet</computeroutput> or <computeroutput>VERROU_DD_QUIET</computeroutput>
          </term>
        <listitem>
            <para>
	      Option to reduce the verbosity of <command>verrou_dd_*</command>.
	    </para>
          </listitem>
        </varlistentry>


	<varlistentry>
          <term>
	    <computeroutput>--cache=</computeroutput> or <computeroutput>VERROU_DD_CACHE</computeroutput>
          </term>
          <listitem>
            <para>
	      Option to choose the policy with the existing cache <computeroutput>dd.sym</computeroutput>, <computeroutput>dd.line</computeroutput>, <computeroutput>dd.task</computeroutput> or <computeroutput>dd.stdout</computeroutput>
	    </para>
	    <para>
	      <computeroutput>clean</computeroutput>: the previous cache is removed (after reading required information for <computeroutput>--rddmin-heuristics-cache</computeroutput>).
	    </para>
	    <para>
	      <computeroutput>rename</computeroutput>: the previous cache is renamed with time information (time of last symlink creation).
	    </para>
	    <para>
	      <computeroutput>rename_keep_result</computeroutput>: the previous cache is renamed and all configurations not pinpointed by symlink are removed.
	      This option is a compromised between disk usage and the opportunity to used the <computeroutput>--rddmin-heuristics-cache=</computeroutput> option.
	    </para>
	    <para>
	      <computeroutput>keep-run</computeroutput>: the previous cache is kept but the <computeroutput>cmp_script</computeroutput> is run again. Useful when
	      only the <computeroutput>cmp_script</computeroutput> is modified.
	    </para>
	    <para>
	      <computeroutput>continue</computeroutput>: the previous cache is kept for all computation. This option is really useful after manual cache modification to recover computation after
	      error such as <computeroutput>No space left on device</computeroutput> or <computeroutput>job timeout</computeroutput>.
	    </para>

	    <para>
	    The default value is set to <computeroutput>continue</computeroutput> (will probably change soon).
	    </para>
          </listitem>
        </varlistentry>


	<varlistentry>
	  <term>
	    <computeroutput>--rddmin-heuristics-cache=</computeroutput> or <computeroutput>VERROU_DD_RDDMIN_HEURISTICS_CACHE</computeroutput>
          </term>
          <listitem>
            <para>
	      Option to choose the policy with cache to use to prefiltered the rddmin algorithm by previous ddmin results.
	    </para>
	    <para>
	      <computeroutput>none</computeroutput>: the current cache and old cache directory are not used.
	    </para>
	    <para>
	      <computeroutput>cache</computeroutput>: only the current cache directory is used.
	    </para>
	    <para>
	      <computeroutput>all_cache</computeroutput>: the current and old cache directories are used. The old cache directories come from previous run with <computeroutput>rename</computeroutput> or <computeroutput>rename_keep_result</computeroutput> values for <computeroutput>--cache=</computeroutput> option.
	    </para>

	    <para>
	    The default value is set to <computeroutput>none</computeroutput>.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
	  <term>
	    <computeroutput>--rddmin-heuristics-rep=</computeroutput> or <computeroutput>VERROU_DD_RDDMIN_HEURISTICS_REP</computeroutput>
          </term>
          <listitem>
            <para>
	      Option to choose the directory used to prefiltered the rddmin algorithm by previous ddmin results. Can be used multiple times (with option but not with environment variable). Usually
	      useful after a manual cache renaming.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
	  <term>
	    <computeroutput>--rddmin-heuristics-file=</computeroutput> or <computeroutput>VERROU_DD_RDDMIN_HEURISTICS_FILE</computeroutput>
          </term>
          <listitem>
            <para>
	      Option to define an heuristics defined by an include file. Can be used muliple times (with option but not with environment variable). Usually
	      <option>--rddmin-heuristics-rep=</option> is preferred, this option is useful if you want to create your own heuristics.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
	  <term>
	    <computeroutput>--rddmin-heuristics-line-conv</computeroutput> or <computeroutput>VERROU_DD_RDDMIN_HEURISTICS_LINE_CONV</computeroutput>
          </term>
          <listitem>
            <para>
	      Option to shift line numbers of line heuristics. The shift is computed thanks a diff between reference computations. This option is useful
	      for a new delta debug with the same test case and few code modifications. This option can be applied for all tools but is only pertinent for <command>verrou_dd_line</command>.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
	  <term>
	    <computeroutput>--seed</computeroutput> or <computeroutput>VERROU_DD_SEED</computeroutput>
          </term>
          <listitem>
            <para>
	      Option to specify the seed used by <command>verrou_dd_*</command> tools to setup the <computeroutput>VERROU_SEED</computeroutput>. Each sample of a configuration receive a different seed (<computeroutput>VERROU_SEED</computeroutput> read by verrou tool) generated by a pseudo random generator initialized with <computeroutput>VERROU_DD_SEED</computeroutput>.
	      The %i% sample (<computeroutput>dd.run%i%</computeroutput>) of each configuration receive the same seed (<computeroutput>VERROU_SEED</computeroutput>).
	      By default <computeroutput>VERROU_SEED</computeroutput> is not set (ie each verrou run set is own seed).
	      This option is useful for be more reproductible (You have to take care of parallelism, use of <command>verrou_dd_*</command> cache, and reproducibility of run script).
	    </para>
          </listitem>
        </varlistentry>

      </variablelist>
    </simplesect>

    <simplesect>
      <title>Results rddmin </title>
      <para id="vr-manual.verrou_dd.results-rddmin">
        <command>verrou_dd_sym</command> (resp. <command>verrou_dd_line</command>/<command>verrou_dd_task</command>/<command>verrou_dd_stdout</command>) stores many intermediate results within the
        <computeroutput>dd.sym</computeroutput> (resp. <computeroutput>dd.line</computeroutput>/<computeroutput>dd.task</computeroutput>/<computeroutput>dd.stdout</computeroutput>) directory. Synthetic results are present in the form
        of symbolic links named after the pattern: <computeroutput>ddmin-<replaceable>N</replaceable></computeroutput>.
      </para>
      <para>
	The list of all symbols (resp. lines/verrou tasks/stdout tasks) found to be unstable in the
	<computeroutput>ddmin-<replaceable>N</replaceable></computeroutput> set can be retrieved in
	the file: <computeroutput>ddmin-<replaceable>N</replaceable>/dd.include</computeroutput>.
      </para>
      <para>
	The symbolic link <computeroutput>rddmin-cmp</computeroutput>  pinpoints the configuration which is the complement of the union of all ddmin configuration. This successful
	configuration terminates the rddmin algorithm.
      </para>
      <para>
	For debug purpose there is one symbolic link (<computeroutput>FullPerturbation</computeroutput>) to pinpoint the configuration (which should fail) with all symbols (resp. lines) perturbed and another (<computeroutput>NoPerturbation</computeroutput>) to pinpoint the configuration without any perturbation (should be a successful configuration).
      </para>

    </simplesect>

    <simplesect>
      <title>Results ddmax</title>
      <para id="vr-manual.verrou_dd.results">
        <command>verrou_dd_sym</command> (resp. <command>verrou_dd_line</command>/<command>verrou_dd_task</command>/<command>verrou_dd_stdout</command>) stores many intermediate results within
        <computeroutput>dd.sym</computeroutput> (resp. <computeroutput>dd.line</computeroutput> / <computeroutput>dd.task</computeroutput> / <computeroutput>dd.stdout</computeroutput>)
        directories. The ddmax configuration is pinpointed by a symbolic link (<computeroutput>ddmax</computeroutput>).	
      </para>
    </simplesect>

    <simplesect>
      <title>Specific option of <command>verrou_dd_task</command> and <command>verrou_dd_stdout</command> </title>
      <para id="verrou_dd_task_stdout.specific.option">
	<variablelist>
	  <varlistentry>
	    <term>
	      <computeroutput>--stop_start=</computeroutput> or <computeroutput>VERROU_DD_STOP_START</computeroutput>
            </term>
	      <listitem>
		<para>
		  <computeroutput>hard</computeroutput>[default] use the hard stop/start client requests
		</para>
		<para>
		  <computeroutput>soft</computeroutput> use the soft stop/start client requests. It should be used if the code use manual hard stop/start client requests or if the size of tasks is small (typically with python localization).
		</para>
	      </listitem>
	  </varlistentry>
	</variablelist>
      </para>
    </simplesect>

    <simplesect>
      <title>Specific options of <command>verrou_dd_stdout</command> </title>
      <para id="verrou_dd_stdout.specific.option">
        <variablelist>
	  <varlistentry>
	    <term>
	      <computeroutput>--unknown-task=</computeroutput> or <computeroutput>VERROU_DD_UNKNOWN_TASK</computeroutput>
            </term>
            <listitem>
              <para>
		Option to choose the policy of task which are not in the search space.
	      </para>
	      <para>
		<computeroutput>previous</computeroutput>: the status of the previous task is kept
	      </para>
	      <para>
		<computeroutput>stop</computeroutput>: the task is uninstrumented.
	      </para>
	      <para>
		<computeroutput>start</computeroutput>: the task is instrumented.
	      </para>

	      <para>
		The default value is set to <computeroutput>previous</computeroutput>.
	      </para>
            </listitem>
          </varlistentry>

	  <varlistentry>
	      <term>
		<computeroutput>--ignore-empty-line=[true[default]|false]</computeroutput> or <computeroutput>VERROU_DD_IGNORE_EMPTY_LINE</computeroutput>
              </term>
              <listitem>
		<para>
		  Option to define the status of empty-line. If set (by default) the task defined by an empty line is merged with the previous task.
		</para>
              </listitem>
            </varlistentry>

	    <varlistentry>
	      <term>
		<computeroutput>--IOmatch-header=FILE</computeroutput> or <computeroutput>VERROU_DD_IOMATCH_HEADER</computeroutput>
              </term>
              <listitem>
		<para>
This option allow to add the content of FILE in the IOMatch script used by <command>verrou_dd_stdout</command>. In practice it is useful to prevent excessive number of iterations (especially when the additional iterations recover the poor precision of the first ones)  with this kind of <computeroutput>FILE</computeroutput>:
<programlisting>
cmatch: IT=42 *
apply: exit</programlisting>
Be careful the match expression should not match any line of the reference computation.
		</para>
		<para>
		  <command>verrou_dd_stdout</command> tool performs few <computeroutput>FILE</computeroutput> verification, to let the user the full power of the functionalities. But you should keep in mind the use of <computeroutput>bmatch</computeroutput> and <computeroutput>stop/start</computeroutput> actions is really tricky and need a deep understanding of IOMatch and <command>verrou_dd_stdout</command>.
		</para>
              </listitem>
            </varlistentry>

	    <varlistentry>
	      <term>
		<computeroutput>--filter-cmd=CMD</computeroutput> or <computeroutput>VERROU_DD_FILTER_CMD</computeroutput>
              </term>
              <listitem>
            <para>
	      The command <computeroutput>CMD</computeroutput> is used by verrou to replace the stdout lines by the result of the command. CMD reads lines from stdin and write his result to stdout for each line. The command is run only once, so it mean we have to pay attention to bufferization (We may need to use the option <computeroutput>-u</computeroutput> of <computeroutput>sed</computeroutput> or <computeroutput>python3</computeroutput>). The command  <computeroutput>"/usr/bin/sed -u s/debug:.*//"</computeroutput> used together with <computeroutput>--ignore-empty-line=true</computeroutput> may be a way to ignore debug message.
	      If you want to write your own python script, these is an example:
	 <programlisting>
#!/usr/bin/python3 -u
import sys

def applyFilter(strLine,filterList):
    res=strLine
    for filterFnc in filterList:
        res=filterFnc(res)
    return res

def deleteDebug(strLine):
    if "debug" in strLine:
        return ""
    else:
        return strLine

def getLineCharByChar():
    line=""
    while True:
        c=sys.stdin.read(1)
        if line== "\x00": #EOF detected
            return None
        if c=='\n':
            return line
        line+=c

if __name__=="__main__":
    while True:
        line=getLineCharByChar()
        if line==None:
            sys.exit(0)
        print(applyFilter(line, [deleteDebug]))
	 </programlisting>
To avoid problem with bufferization, we need to write your own <computeroutput>readline</computeroutput> function (cf. <computeroutput>getLineCharByChar</computeroutput>) and to use <computeroutput>-u</computeroutput> <computeroutput>python3</computeroutput> option.

	    </para>

	    <para>
	      The first argument of <computeroutput>CMD</computeroutput> has to be an absolute path (or relative if there is no CWD change in <replaceable>run_script</replaceable>). This option is not (yet) able to read the <computeroutput>$PATH</computeroutput> env variable. All the spaces are used to separate command arguments. To prevent this behaviour, the only way is to escape the spaces by backslash.
	    </para>
              </listitem>
            </varlistentry>

	    <varlistentry>
	      <term>
		<computeroutput>--custom-search-space=FILE</computeroutput> or <computeroutput>VERROU_DD_CUSTOM_SEARCH_SPACE</computeroutput>
              </term>
              <listitem>
		<para>
		  The default search space generated may suffer of default. By default all floating point are replace by *. But if floating point are printed as int, there are missing. To bypass the issue it is possible to recover the file <computeroutput>dd.stdout/ref/dd.IOMatch</computeroutput> and perform manually the correction. Usually we only add * but it is also possible to do more complex modification:
		  <itemizedlist>
              <listitem><para>The line order can be modified. Indeed if a line matches two wildcard expressions, the first one is taken into account. So if one expression is more specific than an other one, we should place it first.</para></listitem>


	      <listitem><para>By default the float are wildcarded by * and integer kept. But if we want specified iteration by the error order it is possible to rewrite the following example:
		  <programlisting>
		    IT=0 ERRS=*
		    IT=1 ERRS=*
		    IT=2 ERRS=*
		    IT=3 ERRS=*</programlisting>
		  by this search space :
		  <programlisting>
		    IT=* ERRS=*e-01
		    IT=* ERRS=*e-02
		    IT=* ERRS=*e-03
		    IT=* ERRS=*e-04
		    IT=* ERRS=*e-*
		    IT=* ERRS=*</programlisting>
	      </para></listitem>
            </itemizedlist>
		</para>
              </listitem>
            </varlistentry>

	    <varlistentry>
	      <term>
		<computeroutput>--file-pattern=FILE_PATTERN</computeroutput> or <computeroutput>VERROU_DD_FILE_PATTERN</computeroutput>
              </term>
              <listitem>
		<para>
		  The stdout file can be replaced by the first file which matches the <computeroutput>FILE_PATTERN</computeroutput>. The <computeroutput>FILE_PATTERN</computeroutput> has to match only one opened file.
		  To avoid difficulties with the absolute and relative path, the easiest way is to use a wildcard * for the path. If you want to be more precise,
		  you could use a <computeroutput>strace</computeroutput> command to know how a file is opened:
		  <programlisting>
strace -e openat,open,creat -f -ff -o strace_verrou MYPROG MYARGS
cat strace_verrou.*</programlisting>
		</para>
	      </listitem>
            </varlistentry>
        </variablelist>
      </para>

    </simplesect>

    <simplesect  id="vr-manual.verrou_task">
      <title>Definition of verrou task</title>
      <para>
      A verrou task is defined by a key string and an index integer. The integer is usually used to specify a line of code or an iteration number. If you want to use both, you have to build a string post-fixed by one of both integers. If you need neither of both, 0 is fine.

      The task represents the code between the verrou task call and the next one (or finalyze call).
      </para>
      <variablelist>
      <varlistentry><term>C API</term>
	<listitem>
	  <para>
	    <programlisting>#include "libverrouTask.h"</programlisting>
	    <programlisting>
void verrou_task_init();
void verrou_task(char const*const key, int index);
void verrou_task_finalyze();</programlisting>
	    To link you need to use the following link flag : <computeroutput>-lverrouTask</computeroutput>
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry><term>Python API</term>
	<listitem>
	  <para>
	    The python API does not contain init and finalyze as it is done automatically by the module import.
	    <programlisting>
#!/usr/bin/python3
import valgrind.verrouPyBinding as verrou

verrou.task("taskString", taskInt)</programlisting>
</para>

<para>
	  You can notice  that verrouPyBinding can also provide binding to <link linkend="vr-manual.client-requests">other client requests</link>:
	  <programlisting>
#!/usr/bin/python3
import valgrind.verrouPyBinding as verrou

verrou.start_instrumentation()
verrou.stop_instrumentation()
verrou.start_soft_instrumentation()
verrou.stop_soft_instrumentation()
index=verrou.dump_cover()
verrou.display_counters()
nbInst=verrou.count_fp_instrumented()
nbNotInst=verrou.count_fp_not_instrumented()</programlisting>
</para>
</listitem>
      </varlistentry>

      <varlistentry><term>Python module instrumentation</term>
	<listitem>
	  <para>
	    The <computeroutput>trace_verrou_task.py</computeroutput> is a fork of trace.py (provided by cpython distribution) which add verrou task for each python line. The key is the filename and the index the line number.

	    To use it with <computeroutput>verrou_dd_task</computeroutput> it imply to modify the run script following the example:
	    <programlisting>
#!/bin/bash
DIR=$1
valgrind --tool=verrou --rounding-mode=random  trace_verrou_task.py ./myPythonProg.py > $DIR/res.dat</programlisting>
	    </para>
	</listitem>
	</varlistentry>


      <varlistentry><term>Remarks:</term>
	<listitem>
	  <para>
	    <itemizedlist>
		<listitem>
		  <para>
		    The APIs are not thread safe. As valgrind sequentialize threads, it is usually not an issue. But if due to parallelism, it is not clear which code is contained in the task, the user may have to modify his own code to suppress ambiguities.
		  </para>
		</listitem>
		<listitem>
		  <para>
		    Internal use of environnement variables:
		    <itemizedlist>
		      <listitem><para>
			<computeroutput>DEBUG_PRINT_TASK</computeroutput>: configure the debug status
		      </para></listitem>
		      <listitem><para>
			<computeroutput>TASK_LIST</computeroutput>: read the file to setup which tasks are instrumented.
		      </para></listitem>
		      <listitem><para>
			<computeroutput>GENERATE_TASK_LIST</computeroutput>: generate the file containing the list of tasks.
		      </para></listitem>
		      <listitem><para>
			<computeroutput>GENERATE_TASK_FP_LIST</computeroutput>: generate the file containing the list of tasks containing instrumented floating point operation.
		      </para></listitem>
		    </itemizedlist>
		  </para>
		</listitem>
	    </itemizedlist>
	  </para>
	</listitem>
	</varlistentry>
      </variablelist>
    </simplesect>
  </section>

  <section id="vr-manual.verrou_dd_chain">
    <title>Sequence of call between different <command>verrou_dd_*</command></title>

    <para>
    When the search space is too coarse, it can be interesting to run a delta-debug with a refined search space but
    applied to only to coarse ddmin.

    The classical exemples are:

    <variablelist>
      <varlistentry><term>verrou_dd_sym => verrou_dd_line</term>
	<listitem>
	  <para>
    <programlisting>$ verrou_dd_sym --nruns=6 --num-threads=6 ddRun.sh ddCmp.py
$ #Need more details about ddmin1
$ VERROU_DD_EXCLUDE=./dd.sym/ddmin1/dd.sym.exclude verrou_dd_line --nruns=6 --num-threads=6 ddRun.sh ddCmp.py</programlisting>

      <note><para>
	If your script <command>ddRun.sh</command> already use <command>VERROU_DD_EXCLUDE</command>, you will need to modify manually <command>ddRun.sh</command>
	to use <option>--exclude</option> option which can be used multiple times.
      </para></note>

	  </para>
	</listitem>
      </varlistentry>

      <varlistentry><term>verrou_dd_line => verrou_dd_back</term>
      <listitem>
	<para>
	  <programlisting>$ verrou_dd_line --nruns=6 --num-threads=6 ddRun.sh ddCmp.py
$ #Need more details about ddmin0
$ VERROU_DD_SOURCE=./dd.sym/ddmin0/dd.line.include verrou_dd_back --nruns=6 --num-threads=6 ddRun.sh ddCmp.py</programlisting>


      <note><para>
	Your script <command>ddRun.sh</command> should not use <command>VERROU_DD_SOURCE</command>, as it is incompatible with <command>verrou_dd_line</command>.
      </para></note>
	</para>
      </listitem>
      </varlistentry>

      <varlistentry><term>verrou_dd_line => verrou_dd_stdout</term>
      <listitem>
	<para>
	  <programlisting>$ verrou_dd_line --nruns=6 --num-threads=6 ddRun.sh ddCmp.py
$ #Need more details about ddmin0
$ VERROU_DD_SOURCE=./dd.sym/ddmin0/dd.line.include verrou_dd_stdout --nruns=6 --num-threads=6 ddRun.sh ddCmp.py</programlisting>


	</para>
      </listitem>
      </varlistentry>

      <varlistentry><term>verrou_dd_sym => verrou_dd_line => verrou_dd_back</term>
      <listitem>
	<para>
	  <programlisting>$verrou_dd_sym --nruns=6 --num-threads=6 ddRun.sh ddCmp.py
$ #Need more details about ddmin1
	  $ VERROU_DD_EXCLUDE=./dd.sym/ddmin1/dd.sym.exclude verrou_dd_line --nruns=6 --num-threads=6 ddRun.sh ddCmp.py
$ #Need more details about ddmin0
$ VERROU_DD_SOURCE=./dd.sym/ddmin0/dd.line.include verrou_dd_back --nruns=6 --num-threads=6 ddRun.sh ddCmp.py</programlisting>

      <note><para>
	For the last line <command>VERROU_DD_EXCLUDE</command> is not specified again, as the information is implicitly included in <command>VERROU_DD_SOURCE</command>.
      </para></note>
	</para>
      </listitem>
      </varlistentry>


    </variablelist>
    </para>

    <para>
      If you need to run the second <command>verrou_dd_</command> command for muliple ddmin, it is highly recommanded to use the option
      <option>--rep=dd.back.fromLineDDmin0</option>.
    </para>

  </section>
  <section  id="vr-manual.verrou_dd_clean">
    <title> verrou_dd_clean</title>

    <simplesect>
      <title>Decription</title>
      <para id="vr-manual.verrou_dd_clean.description">
	The tool <command>verrou_dd_clean</command> enables to clean the cache repository produced by <command>verrou_dd_*</command> commands (The cache directory is the first argument,
	  and the default value is <command>./</command>).
	  In practice the command removes intermediate configurations which are not result (directories with hash name which are not pinpointed by a symlink).
	</para>
    </simplesect>
      <simplesect>
	<title>Synopsis</title>
	<screen><cmdsynopsis id="vr-manual.verrou_dd_clean.synopsis">
            <command>verrou_dd_clean [options]</command>
            <arg choice="req"><replaceable>/path/to/cache</replaceable></arg></cmdsynopsis></screen>
      </simplesect>


      <simplesect>
	<title>Options</title>

	<variablelist id="vr-manual.verrou_dd_clean.envvars">
          <varlistentry>
          <term>
            <computeroutput>--help</computeroutput>
          </term>
          <listitem>
            <para> Print help</para>
          </listitem>
	  </varlistentry>

	  <varlistentry>
            <term>
              <computeroutput>--dry-run</computeroutput>
            </term>
            <listitem>
              <para>
	      Only print what will do the command. Useful if you need to check carefuly what will be deleted.
	      </para>
            </listitem>
          </varlistentry>
	</variablelist>
      </simplesect>

  </section>

    <section id="vr-manual.localization.coverage" xreflabel="Coverage">
    <title>Code coverage comparison</title>
    <para>
      The first technique to localize unstable tests, is based on the compatibility with instrumentation provided by the compilers.
      The idea is to produce with compiler tools (option <computeroutput>--coverage</computeroutput> and tool <computeroutput>gcov</computeroutput> for <computeroutput>gcc</computeroutput>) two code coverage for the analyzed test case.
      The first one can be generate without verrou or with <computeroutput>nearest</computeroutput> rounding mode and the second one with <computeroutput>random</computeroutput> rounding mode. The second one can be produced several time, to
      get a coverage with sufficient discrepancies compared to the one with  <computeroutput>nearest</computeroutput> rounding mode. Once both code coverage generated, simple graphical tools
      as <computeroutput>meld</computeroutput> or <computeroutput>kompare</computeroutput> can be used to pinpoint potential unstable test.
    </para>
    </section>

    <section id="vr-manual.localization.CovBB" xreflabel="CovBB">
      <title>Basic Block coverage comparison</title>
      <para>
	The second technique to localize unstable tests, is based on Basic Block (BB) Coverage provided by verrou. The idea behind this technique is the same as behind code coverage comparison except in the way to produce the coverage.
	First it is required to specify which part of the code to trace (instrument BB coverage), with a file format similar to symbols exclusion file. To instrument only the binary without libraries the following script can be used:
	<programlisting>
echo "*" ‘readlink -f <replaceable>program</replaceable>‘ > trace.inc</programlisting>

	With the <computeroutput> trace.inc</computeroutput> the BB coverage instrumentation can be activated with the <computeroutput>--trace=</computeroutput> option:
	<programlisting>
valgrind --tool=verrou --rounding-mode=random --trace=trace.inc <replaceable>program args</replaceable></programlisting>

	Hence two files <computeroutput>trace_bb_cov.log-PID</computeroutput> and <computeroutput>trace_bb_info.log-PID</computeroutput> are generated.
	The first one contains counter information for each Basic Blocks and the second one contains debug information for each Basic Bloc. These two files (which must be moved together)
	can be post-treated to be as readable as possible with the <computeroutput>genCovBB</computeroutput> command.
	<programlisting>
genCovBB trace_bb_cov.log-*
</programlisting>

	The differences between generated coverage  are more difficult to analyze compared to the ones generated by code coverage tools, because the code structure is lost. Nevertheless
	it is easier to generate  and can produced really powerful
	information if used with the client request <computeroutput>VERROU_DUMP_COVER</computeroutput> to recover partially time information lost by coverage techniques.
      </para>
      <para>
	The BB coverage generation can be simplified by <command>post_verrou_dd</command>.
      </para>
    </section>

    <section id="vr-manual.localization.post" xreflabel="Post_verrou_dd">
      <title> post_verrou_dd</title>
    <simplesect>
   <title>Synopsis</title>

      <screen><cmdsynopsis id="vr-manual.post_verrou_dd.synopsis">
        <command>post_verrou_dd [options]</command>
        <arg choice="req"><replaceable>/path/to/run_script</replaceable></arg>
        <arg choice="req"><replaceable>/path/to/cmp_script</replaceable></arg>
      </cmdsynopsis></screen>

    </simplesect>

    <simplesect>
      <title>Description</title>
      <para id="vr-manual.post_verrou_dd.description">
	The tool <command>post_verrou_dd</command> enables to post-treat the result repository obtained by <command>verrou_dd_line</command> command.
	The post-treatment consists to run for each selected ddmin configuration new runs with modified (or not) configurations (rounding mode, instruction types).
	For each run it is possible to activate the Basic Bloc coverage generation.
	The scripts <command>run_script</command> and <command>cmp_script</command> are the same parameters of the <command>verrou_dd_line</command> command.
      </para>
    </simplesect>

    <simplesect>
      <title>Options and environment variables</title>

      <variablelist id="vr-manual.post_verrou_dd.envvars">
        <varlistentry>
          <term>
            <computeroutput>--nruns=</computeroutput> or <computeroutput>VERROU_POST_NRUNS</computeroutput>
          </term>
          <listitem>
            <para>An integer setting the run number of each configuration. If this variable is not set, the default value is
            5.</para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
             <computeroutput>--num-threads=</computeroutput> or <computeroutput>VERROU_POST_NUM_THREADS</computeroutput>
          </term>
          <listitem>
            <para> Allows to perform <computeroutput>VERROU_POST_NUM_THREADS</computeroutput> runs in parallel.
	    If this variable is not set, the parallelism is not activated.
	    To use this option <command> run_script </command> has to be thread safe.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
          <term>
             <computeroutput>--rep=</computeroutput> or <computeroutput>VERROU_POST_REP</computeroutput>
          </term>
          <listitem>
            <para>
	      Set the cache repository to find the default configuration.
	      If this variable is not set, its value is  <computeroutput>dd.line</computeroutput>
	    </para>
          </listitem>
        </varlistentry>


	<varlistentry>
          <term>
             <computeroutput>--configuration=</computeroutput> or <computeroutput>--sub-rep=</computeroutput> or <computeroutput>VERROU_POST_CONFIGURATION</computeroutput>
          </term>

          <listitem>
	  <para>
	    The option can be called several times to generate a list of configuration. By default the list contains
	    <computeroutput>$VERROU_POST_REP/ddmin*</computeroutput> , <computeroutput>$VERROU_POST_REP/rddmin-cmp</computeroutput> and <computeroutput>$VERROU_POST_REP/ref</computeroutput>. Each element of the list has to be generated by
	    the verrou_dd and so the directory <computeroutput>../ref</computeroutput> has to exist.
	  </para>
	  </listitem>
        </varlistentry>

	<varlistentry>
          <term>
             <computeroutput>--instr</computeroutput> or <computeroutput>VERROU_POST_INSTR</computeroutput>.
	  </term>
	  <listitem>
	    <para>
	     The option can be called several times to generate a list of instruction type configuration.
	    A configuration is a coma separated list of the following items :
	    <computeroutput>add</computeroutput>,
	    <computeroutput>sub</computeroutput>,
	    <computeroutput>mul</computeroutput>,
	    <computeroutput>div</computeroutput>,
	    <computeroutput>madd</computeroutput>,
	    <computeroutput>msub</computeroutput>,
	    <computeroutput>sqrt</computeroutput>,
	    <computeroutput>conv</computeroutput>.
	    </para>
	    </listitem>
        </varlistentry>

	<varlistentry>
          <term>
             <computeroutput>--rounding=</computeroutput> or <computeroutput>--rounding-mode=</computeroutput> or <computeroutput>VERROU_POST_ROUNDING</computeroutput>.
	     The option can be called several times to generate a list of rounding mode (
	     <computeroutput>random[_[[s]com]det]</computeroutput>,
	     <computeroutput>prandom[_[com]det]</computeroutput>,
	     <computeroutput>average[_[[s]com]det]</computeroutput>,
	     <computeroutput>sr_[s]monotonic</computeroutput>,
	     <computeroutput>nearest</computeroutput>,
	     <computeroutput>native</computeroutput>,
	     <computeroutput>upward</computeroutput>,
	     <computeroutput>downward</computeroutput>,
	     <computeroutput>farthest</computeroutput>,
	     <computeroutput>toward_zero</computeroutput>,
	     <computeroutput>away_zero</computeroutput>
	     )
          </term>
          <listitem>

	    <para>
	      <computeroutput>det</computeroutput> corresponds to the list :
	      [<computeroutput>upward </computeroutput>,
	      <computeroutput>downward</computeroutput>,
	      <computeroutput>farthest</computeroutput>,
	      <computeroutput>toward_zero</computeroutput>,
	      <computeroutput>away_zero</computeroutput>,
	      <computeroutput>nearest</computeroutput>]
	    </para>
	    <para>
	      <computeroutput>no_det</computeroutput> corresponds to the list :
	      [<computeroutput>average</computeroutput>,
	      <computeroutput>random</computeroutput>, <computeroutput>prandom</computeroutput>]
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--trace-bin</computeroutput> or <computeroutput>VERROU_POST_TRACE_BIN</computeroutput>
          </term>
          <listitem>
            <para>
	      Activate the BB coverage trace generation. The verrou trace file is automatically generated with the binary
	      object (without libraries). If the trace file
	      is not the one expected, the option <computeroutput>--trace-file=</computeroutput> has to be used.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--trace-pattern=</computeroutput> or <computeroutput>VERROU_POST_TRACE_PATTERN</computeroutput>
          </term>
          <listitem>
            <para>
	      Activate the BB coverage trace generation. The verrou trace file is automatically generated thanks pattern (* and ?). If the trace file
	      is not the one expected, the option <computeroutput>--trace-file=</computeroutput> has to be used.
	      This option is compatible with <computeroutput>--trace-bin=</computeroutput>. This option can be called several times.
	    </para>
          </listitem>
        </varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--trace-file=</computeroutput> or <computeroutput>VERROU_POST_TRACE_FILE</computeroutput>
          </term>
          <listitem>
            <para>
	      Activate the BB coverage trace generation. The user has to provide  directly a specific trace-file (See Verrou format). This option is incompatible with  
	      <computeroutput>--trace-bin</computeroutput> and <computeroutput>--trace-pattern=</computeroutput>. This option
	      is less convenient than the two previous one but may be required for few corner cases.
	    </para>
          </listitem>
        </varlistentry>

      </variablelist>

    </simplesect>

    </section>
    <section id="vr-manual.plotstat" xreflabel="ploStat">
      <title> verrou_plot_stat</title>
    <simplesect>
   <title>Synopsis</title>

      <screen><cmdsynopsis id="vr-manual.plotstat.synopsis">
        <command>verrou_plot_stat [options] [/path/to/run_script]</command>
        <arg choice="req"><replaceable>/path/to/extract_script</replaceable></arg>
      </cmdsynopsis></screen>

    </simplesect>

    <simplesect>
      <title>Description</title>
      <para id="vr-manual.plotstat.description">
	The tool <command>verrou_plot_stat</command> enables to visualize the histogram
	of the result (extracted with <command> extract_script</command>) of a code run under verrou and to compute the non-gaussian error estimator (results are printed in <command>stdout</command> and in a file <command>stat.last</command>).


      <screen>
refValue[nearest] : 1.05891843750000000e+05
estimator	abs	rel	rel(in bit)
average:	1.034992e+03	9.7741e-03	6.68bit
average_det:	1.036070e+03	9.7842e-03	6.68bit
random:	1.983109e+03	1.8728e-02	5.74bit
random_det:	1.985172e+03	1.8747e-02	5.74bit
all:	4.337773e+03	4.0964e-02	4.61bit
      </screen>


	<itemizedlist>

          <listitem><simpara> The abs estimator is <inlineequation><mathphrase>max<subscript>i</subscript>(|X<subscript>i</subscript>-X<subscript>ref</subscript>|)</mathphrase></inlineequation> .</simpara></listitem>
	  <listitem><simpara> The rel estimator is <inlineequation><mathphrase>max<subscript>i</subscript>(|X<subscript>i</subscript>-X<subscript>ref</subscript>|)/|X<subscript>ref</subscript>|</mathphrase></inlineequation> </simpara></listitem>
          <listitem><simpara> The binary rel estimator is <inlineequation><mathphrase>-log2(max<subscript>i</subscript>(|X<subscript>i</subscript>-X<subscript>ref</subscript>|)/|X<subscript>ref</subscript>|)</mathphrase></inlineequation></simpara></listitem>
          <listitem><simpara>  <computeroutput>all </computeroutput> means the i samples take into account all the sample of previous rounding mode and all deterministic computed rounding mode</simpara></listitem>

	</itemizedlist>

	The scripts <command>run_script</command> is similar to the one of <command>verrou_dd_line</command> command. This script is optional if the computation are already done (by example with
	a previous call to <command>verrou_plot_stat</command> or <command>post_verrou_dd</command>).

	The script <command>extract_script</command> has only one parameter (the repository of computation: the same parameter of <command>run_script</command>). It has to print
	the extracted value on the first line of the standard output.

	To study several output variables the command can be called several times the command with different <command>extract_script</command>. Thanks the cache repository (by default <computeroutput>verrou.stat</computeroutput>) the run commands won't be rerun. There is no guarantee in case of concurrent run of the command verrou_plot_stat and the <command>run_script</command> and <command>extract_script </command> should not be modify during a <command>verrou_plot_stat</command> call.

    </para>
    </simplesect>

    <simplesect>
      <title>Options</title>

      <variablelist id="vr-manual.plotStat.envvars">
	<varlistentry>
          <term>
            <computeroutput>--help=</computeroutput> or <computeroutput>-h</computeroutput>
          </term>
          <listitem>
            <para>
	      Print help.
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--rep=DIR</computeroutput> or <computeroutput>-r DIR</computeroutput>
          </term>
          <listitem>
            <para>
	      Set the repository to store/read computation. By default <computeroutput>DIR</computeroutput> is set
	      to <computeroutput>verrou.stat</computeroutput>. If the option <computeroutput>--specific-pattern</computeroutput> is used
	      the default is set to <computeroutput>./</computeroutput>.
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
          <computeroutput>--cache=continue[default]|clean|rename</computeroutput>
          </term>
	  <listitem>
            <para>
	      Option to choose the policy with the existing cache defined by <computeroutput>--rep</computeroutput> option.
	    </para>
	    <para>
	      <computeroutput>clean</computeroutput>: the previous cache is removed.
	    </para>
	    <para>
	      <computeroutput>rename</computeroutput>: the previous cache is renamed with time information (time of last file modification).
	    </para>
	    <para>
	      <computeroutput>continue</computeroutput>: the previous cache is kept for all computation.
	    </para>
	    </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--samples=</computeroutput> or <computeroutput>--nruns=</computeroutput>  or <computeroutput>-s</computeroutput>
          </term>
          <listitem>
            <para>An integer setting the run number of random and average distribution. If this variable is not set, the default value is
              100. -1 means the highest number without running additional computation.</para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--num-threads=</computeroutput>
          </term>
          <listitem>
            <para>An integer setting the run number of threads to run code thanks <command> run_script </command>.  Default is sequential computation.
	      To use this option <command> run_script </command> has to be thread safe.
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--rounding-list=</computeroutput> or  <computeroutput>--rounding-mode=</computeroutput> or  <computeroutput>--rounding=</computeroutput>
          </term>
          <listitem>
            <para> A coma separated list of rounding mode. The list can contain
	     <computeroutput>random[_[[s]com]det]</computeroutput>,
	     <computeroutput>prandom[_[com]det]</computeroutput>,
	     <computeroutput>average[_[[s]com]det]</computeroutput>,
	     <computeroutput>sr_[s]monotonic</computeroutput>,
	     <computeroutput>nearest</computeroutput>,
	     <computeroutput>native</computeroutput>,
	     <computeroutput>upward</computeroutput>,
	     <computeroutput>downward</computeroutput>,
	     <computeroutput>farthest</computeroutput>,
	     <computeroutput>toward_zero</computeroutput>,
	     <computeroutput>away_zero</computeroutput>
	    </para>

            <para> <computeroutput>nodet</computeroutput> is an alias to <computeroutput>average,random</computeroutput>.
	    </para>
	    <para> <computeroutput>det</computeroutput> is an alias to <computeroutput>nearest,upward,downward,toward_zero,away_zero,farthest</computeroutput>.
	    </para>

	    <para> The list can also contain <computeroutput>prandom_fun</computeroutput>. This rounding mode corresponds to <computeroutput>prandom</computeroutput> with the <xref linkend="vr-manual.feat.updatepfunc"/> set to <computeroutput>func</computeroutput>.
	    </para>

	    <para> The list can also contain <computeroutput>prandom_FLOAT</computeroutput> with <computeroutput>FLOAT</computeroutput> a floating point number between 0 and 1. This rounding mode corresponds to <computeroutput>prandom</computeroutput> with the  <xref linkend="vr-manual.feat.updatepvalue"/>  set to <computeroutput>FLOAT</computeroutput>.
	    </para>
	    <para>
	    If the option is set multiple times, the list will be append to the current list.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--montecarlo</computeroutput> or <computeroutput>-m</computeroutput>
          </term>
          <listitem>
            <para> If this option is set, the deterministic mode use also the number of sample defined by <computeroutput>--samples=</computeroutput>.
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--png=FILE</computeroutput> or <computeroutput>-p FILE</computeroutput>
          </term>
          <listitem>
            <para> Defined the output file for histogram. By default the plot is interactive.
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--nb-bin=VALUE</computeroutput>
          </term>
          <listitem>
            <para>
	      Set the number of histogram bins to VALUE. The default value is 40.
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--no-plot</computeroutput>
          </term>
          <listitem>
            <para>
	      Do not plot histogram. Only the error estimators are computed.
	    </para>
          </listitem>
	</varlistentry>
	<varlistentry>
          <term>
            <computeroutput>--run-only</computeroutput>
          </term>
          <listitem>
            <para>
	      Neither  plot the  histogram nor compute the error estimators.
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--relative=VALUE</computeroutput> or <computeroutput>-r VALUE</computeroutput>
          </term>
          <listitem>
            <para> With this option the abscissa is relative. The reference (defined by VALUE) is either a numerical value
	      or a key to a rounding mode (nearest, upward, ...)
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--ref=VALUE</computeroutput>
          </term>
          <listitem>
            <para> This option is used to defined the reference used to compute accuracy estimator. The VALUE is key to a rounding mode (nearest, upward, ...). If the rounding mode is not deterministic, the average value is taken.
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--continue-on-extract-value-error</computeroutput>
          </term>
          <listitem>
            <para> This option is used to be able to plot and compute estimator even if few samples produce an execution error. If errors occur the plot and the stat indicate the failure rate. This option is not activated by default, as usually errors come from error in the extract script.
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--mca=MODE-DBL-FLT</computeroutput>
          </term>
          <listitem>
            <para> Add the MODE-DBL-FLT mca mode to the study. MODE has to be in ["rr","pb","mca"]. DBL is mca noise for double and FLT for float.
	      Typical configuration is  <computeroutput>--mca=rr-53-24</computeroutput>
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
          <term>
            <computeroutput>--specific-pattern=</computeroutput>
          </term>
          <listitem>
            <para> This option enables to plot histogram for computation run without the framework or after files renaming.
	      Typical calls are:
	    </para>
	    <para>
	      <computeroutput>--rep="." --specific-pattern=verrou.stat/random/dd.run* </computeroutput>
	    </para>
	    <para>
	      <computeroutput>--rep="verrou.stat" --specific-pattern=random/dd.run* </computeroutput>
	    </para>
          </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
	    <computeroutput>--seed=</computeroutput>
          </term>
	  <listitem>
	    <para>
	      Option to specify the seed used by <command>verrou_plot_stat</command> tool to setup the <computeroutput>VERROU_SEED</computeroutput>. This option is similar to <option>--seed</option> of <command>verrou_dd_*</command>.
	    </para>
	  </listitem>

	</varlistentry>
      </variablelist>

    </simplesect>

    </section>


</section>

<!-- Local Variables: -->
<!-- mode: nxml -->
<!-- fill-column: 100 -->
<!-- End: -->
